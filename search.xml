<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows上安装 MySQL]]></title>
    <url>%2F7d2a91d4%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;&ensp; Window上安装MySQL主要有两种方式：第一种，MySQL安装包安装方式；第二种，绿色版压缩包安装方式。第一种方式相对简单，就是简单的点击下一步安装，不再赘述，本文主要讲解第二种方式的安装及安装过程中出现问题的解决方式。下载安装包&ensp;&ensp;&ensp;&ensp;&ensp;进入MySQL 下载,可以看到mysql的下载包列表。我选择的是5.7版本。安装配置将下载好的压缩包文件解压到指定目录，比如D:\mysql-5.7.20-winx64；配置下 MySQL 的配置文件，打开刚刚解压的文件夹 D:\mysql-5.7.20-winx64 ，修改my-default.ini为my.ini，如果不存在直接创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：1234567891011121314151617181920# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[client]port=3306default-character-set=utf8[mysqld] # 设置为自己MYSQL的安装目录 basedir=D:\mysql-5.7.20-winx64# 设置为MYSQL的数据目录 datadir=D:\mysql-5.7.20-winx64\dataport=3306character_set_server=utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES#开启查询缓存explicit_defaults_for_timestamp=true#默认的存储引擎default-storage-engine=INNODB上面这个是5.7版本的配置,MySQL 8+配置如下：1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB启动 MySQL 数据库以管理员身份打开 cmd 命令行工具，切换目录：1C:\Users\sunys&gt;cd D:\mysql-5.7.20-winx64\bin初始化数据库：1D:\mysql-5.7.20-winx64\bin&gt;mysqld --initialize --user=mysql--console此时会给管理账户root随机生成一个临时密码。安装Mysql服务1D:\mysql-5.7.20-winx64\bin&gt;mysqld --install MySQL启动服务1D:\mysql-5.7.20-winx64\bin&gt;net start mysql登录数据库当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:1mysql -h 主机名 -u 用户名 -p-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;-u : 登录的用户名;-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。我是登录本机的 MySQL 数据库，只需要输入以下命令即可：1D:\mysql-5.7.20-winx64\bin&gt;mysql -u root -p按回车确认，输入之前生成的临时密码。成功登录后需要首先修改root账户的随机密码1mysql&gt;alter user&apos;root&apos;@&apos;localhost&apos; identified by &apos;密码&apos;;密码修改成功后即可使用自己设定的密码登录卸载卸载安装版方式安装的MySQL跟卸载普通的软件方式一样，直接在控制面板的程序和功能中卸载即可；绿色版安装的MySQL卸载方式如下：在CMD命令行模式下，删除mysql服务1C:\Users\sunys&gt;sc delete mysqlregedit进入注册表，删除mysql相关的文件问题及解决方案缺少dll安装版，遇到MSVCR120.dll文件丢失错误，如下图：解决方案:下载 VC redist packages for x64,安装即可。]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA开发中的设计模式]]></title>
    <url>%2F25810b4c%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;在《java抽象类和模板方法设计》中,讲到了利用接口和抽象类进行模板方法设计。在我们实际开发的过程中，最多的操作可能就是curd堆业务代码，只有负责架构的才会去考虑设计模式相关的东西，然而呢，其实我们接触到与java设计模式相关的还是很多，例如，jDK源码，几乎每个web项目都会使用的企业级应用分层框架spring框架等。&ensp;&ensp;&ensp;&ensp;在软件开发过程中，对于软件架构的设计，我们需要从耦合性、内聚性以及可维护性、可扩展性、重用性、灵活性等多方面进行考虑，设计模式的出现在这些方面为我们提供了思路和解决方案。设计模式的七大原则&ensp;&ensp;&ensp;&ensp;设计模式的原则，指的就是我们在软件编程的过程中，应该遵循的原则，它是设计模式的基础和依据，主要有七大原则：单一职责原则 (Single Responsibility Principle)开闭原则（Open Close Principle）里氏代换原则（Liskov Substitution Principle）依赖倒转原则（Dependence Inversion Principle）接口隔离原则（Interface Segregation Principle）迪米特法则（Demeter Principle）合成复用原则（Composite Reuse Principle）设计模式的分类总体来说设按照功能可将计模式分为三大类：分类功能设计模式创建型模式主要用于创建对象、抽象工厂模式、单例模式、建造者模式、原型模式结构型模式主要用于处理类或者对象的组合适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式行为型模式主要用于描述对类或对象怎样交互和怎样分配职责策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式其实还有两类：并发型模式和线程池模式。创建型模式（Creational patterns）&ensp;&ensp;&ensp;&ensp;创建型模式，顾名思义就是用来创建对象的设计模式，所以这种类型的模式主要用途是就用于创建对象，关注点是对象的创建。这种类型的设计模式主要特点是将创建对象的过程进行了抽象，封装，对于对象的使用者而言只需调用，而不需要去关心对象创建的过程如何。结构型模式（Structural patterns）&ensp;&ensp;&ensp;&ensp;结构型设计模式，为我们如何组合类和对象以获得更大的结构提供思路，从程序的结构上解决模块之间的耦合问题。&ensp;&ensp;&ensp;&ensp;从组合结构上来看，又可以分为两类：类结构型模式、对象结构型模式。类结构型模式主要关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；对象结构型模式则主要关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法，更符合“合成复用原则”。行为型模式（Behavioral patterns）&ensp;&ensp;&ensp;&ensp;行为型模式，是设计模式中最为庞大的一类，前面两类模式已经解决了对象的创建问题及类和对象的组合结构问题，那么这第三大类型的模式自然就是用来解决类或对象相互协作的问题。这类设计模式主要用于描述程序在运行时复杂的流程控制，例如分配算法与对象间职责，协调类或对象之间相互协作等。&ensp;&ensp;&ensp;&ensp;当然，行为型模式也可分为两类：类行为模式、对象行为模式。类行为模式采用继承机制来在类间分派行为，对象行为模式则采用组合或聚合在对象间分配行为；由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。设计模式之间的关系给两张图 设计模式在软件中的应用graph LR A(面向对象) -->|设计模式+算法+数据结构| B[功能模块] B -->|多种设计模式| C[框架] C -->|服务器集群| D[架构]总结&ensp;&ensp;&ensp;&ensp;设计模式实际是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的问题解决方案，当我们在软件开发过程中面临一般问题时，不妨从这方面入手看是否能找到解决方法。&ensp;&ensp;&ensp;&ensp;设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>design</tag>
        <tag>patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java抽象类和模板方法设计]]></title>
    <url>%2F4fb5687d%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;最近，在做项目时，遇到一个业务场景是这样的：有一种类型的电子锁，开锁的方式有两种，这两种方式开锁的过程有不同的地方也有相同的地方，主要的开锁流程差不多一致，设计这两种方式开锁流程的时候，我想到了利用java抽象类来进行模板方法设计。Java抽象类与接口的区别&ensp;&ensp;&ensp;&ensp;面试的过程中，很多面试官考察java基础知识的时候，通常都会问诸如“Java抽象类与接口有什么区别？请你说说两者各自的使用场景？”这样的问题，那么两者有什么区别呢，大概总结如下：参数抽象类接口默认的方法实现它可以有默认的方法实现接口完全是抽象的。它根本不存在方法的实现实现子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现构造器抽象类可以有构造器接口不能有构造器与正常Java类的区别除了你不能实例化抽象类之外，它和普通Java类没有任何区别接口是完全不同的类型成员变量抽象类中的静态成员变量的访问类型可以任意接口中定义的变量只能是public static final类型，并且默认即为public static final类型。成员方法抽象方法可以有public、protected和default这些修饰符，可以包含静态方法接口方法默认修饰符是public，并且默认即为public abstract类型，不能包含静态方法多继承抽象方法可以继承一个类和实现多个接口接口只可以继承一个或多个其它接口速度它比接口速度要快接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。添加新方法如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。Java抽象类与接口的使用场景interface的应用场合类与类之前需要特定的接口进行协调，而不在乎其如何实现;作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识;需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联;需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。USB.java1234public interface USB&#123; // 定义了USB接口 void start() ; // USB设备开始工作 void stop() ; // USB设备结束工作&#125;Flash.java12345678public class Flash implements USB&#123; public void start()&#123; // 覆写方法 System.out.println("U盘开始工作。") ; &#125; public void stop()&#123; // 覆写方法 System.out.println("U盘停止工作。") ; &#125;&#125;Print.java12345678public class Print implements USB&#123; public void start()&#123; // 覆写方法 System.out.println("打印机开始工作。") ; &#125; public void stop()&#123; // 覆写方法 System.out.println("打印机停止工作。") ; &#125;&#125;abstract class的应用场合在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它,例如：规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。Person.java123456789101112131415161718public abstract class Person&#123; private String name ; // 定义name属性 private int age ; // 定义age属性 public Person(String name,int age)&#123; this.name = name ; this.age = age ; &#125; public String getName()&#123; return this.name ; &#125; public int getAge()&#123; return this.age ; &#125; public void say()&#123; // 人说话是一个具体的功能 System.out.println(this.getContent()) ; // 输出内容 &#125; public abstract String getContent() ; // 说话的内容由子类决定&#125;Student.java123456789101112public class Student extends Person&#123; private float score ; public Student(String name,int age,float score)&#123; super(name,age) ; // 调用父类中的构造方法 this.score = score ; &#125; public String getContent()&#123; return "学生信息 --&gt; 姓名：" + super.getName() + "；年龄：" + super.getAge() + "；成绩：" + this.score ; &#125;&#125;Worker.java123456789101112public class Worker extends Person&#123; private float salary ; public Worker(String name,int age,float salary)&#123; super(name,age) ; // 调用父类中的构造方法 this.salary = salary ; &#125; public String getContent()&#123; return "工人信息 --&gt; 姓名：" + super.getName() + "；年龄：" + super.getAge() + "；工资：" + this.salary ; &#125;&#125;&ensp;&ensp;&ensp;&ensp;在实际开发过程中，接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用。模板方法设计模式就是抽象类的一个典型应用，工厂模式、代理设计模式都是通过implements实现接口的设计模式，范型则是装饰设计模式。&ensp;&ensp;&ensp;&ensp;关于java开发中的23种设计模式，在下文《JAVA开发中的设计模式》继续。。。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>abstract</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web应用安全之XSS攻击]]></title>
    <url>%2Fafd61e4d%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;在上一篇文章《web应用安全之SQL注入》中，本人从java的角度就Java web开发过程中SQL注入的问题简单表达了下自己的观点，本文将在上一文的基础上继续讲述web应用安全的另一个问题————XSS攻击。什么是XSS攻击&ensp;&ensp;&ensp;&ensp;XSS攻击，全称是“跨站点脚本攻击”（Cross Site Scripting），之所以缩写为XSS，主要是为了和“层叠样式表”（Cascading Style Sheets，CSS）区别开。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击原理攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）;诱使受害者打开受到攻击的服务器URL;受害者在Web浏览器中打开URL，恶意脚本执行。一个简单演示代码如下：&ensp;&ensp;&ensp;&ensp;从上面的代码可以看出，输入框被非法放入了一段js代码，当浏览器解析到这段代码时，浏览器并不知道这些代码改变了原本程序的意图，会照做弹出一个信息框。XSS攻击的类型&ensp;&ensp;&ensp;&ensp;常见的 XSS 攻击有三种：反射型、DOM-based 型、存储型。 其中反射型、DOM-based 型可以归类为非持久型 XSS 攻击，存储型归类为持久型 XSS 攻击。反射型&ensp;&ensp;&ensp;&ensp;用户在页面输入框中输入数据，通过 get 或者 post 方法向服务器端传递数据，输入的数据一般是放在 URL 的 query string 中，或者是 form 表单中，如果服务端没有对这些数据进行过滤、验证或者编码，直接将用户输入的数据呈现出来，就可能会造成反射型 XSS。&ensp;&ensp;&ensp;&ensp;上面这个请求地址被非法注入了js代码，当name的参数值（脚本标记）被后端代码重新下发给前端时，脚本标记就会在前端被执行，从而触发反射型XSS。DOM-based 型&ensp;&ensp;&ensp;&ensp;DOM 是一个树形结构，攻击者可以通过写 js 代码来修改节点，对象和值。如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的处理，那么应用程序就可能受到DOM-based XSS攻击。&ensp;&ensp;&ensp;&ensp;本文在讲述XSS攻击原理时，演示了一个非法注入的HTML页面，如果在这个页面的基础上执行如下js，将会发生DOM-based XSS攻击。123var content = document.getElementById("content"); var board = document.getElementById("board");board.innerHTML = text.value; //发生DOM-based XSS攻击存储型&ensp;&ensp;&ensp;&ensp;存储型XSS攻击也可以说是持久型XSS攻击，通常是因为服务器端将用户输入的恶意脚本没有经过验证就存储在数据库中，并且通过调用数据库的方式，将数据呈现在浏览器上，当页面被用户打开的时候执行，每当用户打开浏览器，恶意脚本就会执行。持久型的 XSS 攻击相比非持久型的危害性更大，因为每当用户打开页面，恶意脚本都会执行。&ensp;&ensp;&ensp;&ensp;假如XSS攻击原理演示中的id为content的输入框内容被提交，如果后台没有做过滤处理，服务端将内容保存到数据库，当从后台再次取出数据在前端展示时，就会执行这些恶意攻击代码，并且这种攻击每次打开都会发生。XSS的防御措施编码&ensp;&ensp;&ensp;&ensp;对用户输入的数据进行编码HTML 编码&ensp;&ensp;&ensp;&ensp;将不可信数据放入到 HTML 标签内（例如div、span等）的时候进行HTML编码显示结果描述实体编号空格&amp;nbsp ;&lt;小于&amp;lt ;&gt;大于&amp;gt ;&amp;和&amp;amp ;‘’引号&amp;quot ;123456789function encodeForHTML(str, kwargs)&#123; return ('' + str) .replace(/&amp;/g, '&amp;amp;') .replace(/&lt;/g, '&amp;lt;') // DEC=&gt; &amp;#60; HEX=&gt; &amp;#x3c; Entity=&gt; &amp;lt; .replace(/&gt;/g, '&amp;gt;') .replace(/"/g, '&amp;quot;') .replace(/'/g, '&amp;#x27;') // &amp;apos; 不推荐，因为它不在HTML规范中 .replace(/\//g, '&amp;#x2F;'); &#125;;HTML Attribute 编码&ensp;&ensp;&ensp;&ensp;将不可信数据放入 HTML 属性时（不含src、href、style 和事件处理属性），进行 HTML Attribute 编码，除了字母数字字符以外，使用 &#xHH;(或者可用的命名实体)格式来转义ASCII值小于256所有的字符​​​​​​​1234567891011function encodeForHTMLAttibute(str, kwargs)&#123; let encoded = ''; for(let i = 0; i &lt; str.length; i++) &#123; let ch = hex = str[i]; if (!/[A-Za-z0-9]/.test(str[i]) &amp;&amp; str.charCodeAt(i) &lt; 256) &#123; hex = '&amp;#x' + ch.charCodeAt(0).toString(16) + ';'; &#125; encoded += hex; &#125; return encoded; &#125;;JavaScript 编码&ensp;&ensp;&ensp;&ensp;将不可信数据放入事件处理属性、JavaScirpt值时进行 JavaScript 编码，除字母数字字符外，使用\xHH格式转义ASCII码小于256的所有字符1234567891011function encodeForJavascript(str, kwargs) &#123; let encoded = ''; for(let i = 0; i &lt; str.length; i++) &#123; let cc = hex = str[i]; if (!/[A-Za-z0-9]/.test(str[i]) &amp;&amp; str.charCodeAt(i) &lt; 256) &#123; hex = '\\x' + cc.charCodeAt().toString(16); &#125; encoded += hex; &#125; return encoded; &#125;;URL 编码&ensp;&ensp;&ensp;&ensp;将不可信数据作为URL参数值时需要对参数进行encodeURIComponent编码123function encodeForURL(str, kwargs)&#123; return encodeURIComponent(str); &#125;;CSS 编码&ensp;&ensp;&ensp;&ensp;将不可信数据作为 CSS 时进行 CSS 编码，除了字母数字字符以外，使用\XXXXXX格式来转义ASCII值小于256的所有字符1234567891011121314function encodeForCSS (attr, str, kwargs)&#123; let encoded = ''; for (let i = 0; i &lt; str.length; i++) &#123; let ch = str.charAt(i); if (!ch.match(/[a-zA-Z0-9]/)) &#123; let hex = str.charCodeAt(i).toString(16); let pad = '000000'.substr((hex.length)); encoded += '\\' + pad + hex; &#125; else &#123; encoded += ch; &#125; &#125; return encoded; &#125;;Http Only cookie&ensp;&ensp;&ensp;&ensp;许多 XSS 攻击的目的就是为了获取用户的 cookie，将重要的 cookie 标记为 http only，这样的话当浏览器向服务端发起请求时就会带上 cookie 字段，但是在脚本中却不能访问 cookie，这样就避免了 XSS 攻击利用 js 的 document.cookie获取 cookie。使用 XSS Filter&ensp;&ensp;&ensp;&ensp;在上一篇文章《web应用安全之SQL注入》中,讲SQL注入的防范与处理时，提到了自定义过滤规则防范SQL注入,同样的对于XSS我们也可以自定义过滤规则防范XSS攻击，我们只需要在重写getParameter方法中调用XSS的过滤规则即可，详情不在赘述。附：2017 年公布了十大安全漏洞列表注入失效的身份认证敏感信息泄漏XML 外部实体（XXE）失效的访问控制安全配置错误跨站脚本（XSS）不安全的反序列化使用含有已知漏洞的组件不足的日志记录和监控]]></content>
      <categories>
        <category>technology</category>
        <category>Safety</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>injection</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合Quartz分布式调度]]></title>
    <url>%2Fa0757df1%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;最近在做项目时，项目中涉及到很多定时任务相关的功能，并且很多定时都是动态的。为了业务开发时定时调度更加方便，且能清晰的管理所有定时任务，我决定将调度中心这个模块做成可视化的管理界面；此外，考虑到后期项目的壮大，应用的高可用和高并发性，可能会有采用集群部署多个节点；对于定时任务，如果每个节点都执行自己的定时任务，一方面耗费了系统资源，另一方面有些任务多次执行，可能引发应用逻辑问题，所以需要一个分布式的调度系统，来协调每个节点执行定时任务，定时任务采用动态配置并持久化到数据库。版本选择&ensp;&ensp;&ensp;&ensp;spring对于quartz的支持，是通过org.springframework.scheduling.quartz.CronTriggerBean继承org.quartz.CronTrigger来实现的。在quartz1.x系列中org.quartz.CronTrigger是个类，而在quartz2.x系列中org.quartz.CronTrigger变成了接口，这就造成了无法用spring的方式配置quartz的触发器（trigger）。因此，在spring3.1以下的版本必须使用quartz1.x系列，3.1以上的版本才支持quartz 2.x，否则会出错。&ensp;&ensp;&ensp;&ensp;本次采用版本：spring版本4.3.5.RELEASE，quartz版本2.3.0Spring整合QuartzMaven依赖文件pom.xml123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--分布式调度持久化选用mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.29&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;配置job&ensp;&ensp;&ensp;&ensp;Quartz是一个成熟的任务调度系统提供了两种方式来配置job，分别是：MethodInvokingJobDetailFactoryBeanJobDetailFactoryBeanMethodInvokingJobDetailFactoryBean要调用特定bean的一个方法的时候使用，具体配置如下：applicationContext-job.xml1234&lt;bean id="firstTask" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="springFrameworkQuartzJobDemo" /&gt; &lt;property name="targetMethod" value="springFrameworkQuartzJobDemoJob" /&gt;&lt;/bea&gt;JobDetailFactoryBean这种方式更加灵活，可以设置传递参数，具体配置如下：applicationContext-job.xml1234567891011121314&lt;bean id="springFrameworkQuartzJobDemoBeanId" class="org.springframework.scheduling.quartz.JobDetailFactoryBean"&gt; &lt;property name="jobClass" value="com.syshlang.quartz.core.quartz.schedulerframework.SpringFrameworkQuartzJobDemo"/&gt; &lt;property name="name" value="springFrameworkQuartzJobDemoJob"/&gt; &lt;property name="durability" value="true" /&gt; &lt;!-- &lt;property name="jobDataMap"&gt; &lt;map&gt; &lt;entry key="firstService" value-ref="firstService" /&gt; &lt;/map&gt; &lt;/property&gt; --&gt;&lt;/bean&gt;jobClass定义的任务类，继承QuartzJobBean，实现executeInternal方法；可以使用jobDataMap来给job传递数据;配置调度触发器调度的触发器同样也提供了两种类型，分别是：SimpleTriggerFactoryBeanCronTriggerFactoryBeanCronTriggerFactoryBean相对更加灵活，本例中也是采用这种类型的触发器，如下：applicationContext-job.xml1234567891011121314151617&lt;!-- 执行定时器 --&gt;&lt;bean id="springFrameworkQuartzJobDemoId" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;!-- 每隔5秒执行一次：*/5 * * * * ? 每隔1分钟执行一次：0 */1 * * * ? 每天23点执行一次：0 0 23 * * ? 每天凌晨1点执行一次：0 0 1 * * ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * * * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? --&gt; &lt;property name="cronExpression" value="*/5 * * * * ?"/&gt; &lt;property name="jobDetail" ref="springFrameworkQuartzJobDemoBeanId"/&gt;&lt;/bean&gt;配置Quartz调度器的SchedulerFactoryBeanQuartz调度器的SchedulerFactoryBean同样也提供了两种方式：内存RAMJobStore数据库方式RAMJobStorejob的相关信息存储在内存里，每个节点存储各自的，互相隔离，配置如下：applicationContext-job.xml123456789&lt;bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean" lazy-init="false"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="springFrameworkQuartzJobDemoId" /&gt; &lt;!-- 如果有多个定时任务就在这里添加 --&gt; &lt;!-- &lt;ref bean="quartzTrigger2" /&gt; --&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;数据库方式&ensp;&ensp;&ensp;&ensp;job的相关信息存储在数据库中，所有节点共用数据库，每个节点通过数据库来通信，保证一个job同一时间只会在一个节点上执行，并且如果某个节点挂掉，job会被分配到其他节点执行，这也是集群部署时，分布式的调度系统采用的方式。其原理如下：具体配置如下：applicationContext-job.xml123456789101112131415161718192021222324252627282930&lt;bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean" lazy-init="false"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="quartzProperties"&gt; &lt;props&gt; &lt;prop key="org.quartz.scheduler.instanceName"&gt;EBMDynamicQuartz&lt;/prop&gt; &lt;prop key="org.quartz.scheduler.instanceId"&gt;AUTO&lt;/prop&gt; &lt;!-- 线程池配置 --&gt; &lt;prop key="org.quartz.threadPool.class"&gt;org.quartz.simpl.SimpleThreadPool&lt;/prop&gt; &lt;prop key="org.quartz.threadPool.threadCount"&gt;20&lt;/prop&gt; &lt;prop key="org.quartz.threadPool.threadPriority"&gt;5&lt;/prop&gt; &lt;!-- JobStore 配置 --&gt; &lt;prop key="org.quartz.jobStore.class"&gt;org.quartz.impl.jdbcjobstore.JobStoreTX&lt;/prop&gt; &lt;!-- 集群配置 --&gt; &lt;prop key="org.quartz.jobStore.isClustered"&gt;true&lt;/prop&gt; &lt;prop key="org.quartz.jobStore.clusterCheckinInterval"&gt;15000&lt;/prop&gt; &lt;prop key="org.quartz.jobStore.maxMisfiresToHandleAtATime"&gt;1&lt;/prop&gt; &lt;prop key="org.quartz.jobStore.misfireThreshold"&gt;120000&lt;/prop&gt; &lt;prop key="org.quartz.jobStore.tablePrefix"&gt;QRTZ_&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="schedulerName" value="EBMDynamicQuartz" /&gt; &lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&gt; &lt;property name="startupDelay" value="30" /&gt; &lt;property name="applicationContextSchedulerContextKey" value="applicationContextKey" /&gt; &lt;!--可选，QuartzScheduler 启动时更新己存在的Job，这样就不用每次修改targetObject后删除qrtz_job_details表对应记录了 --&gt; &lt;property name="overwriteExistingJobs" value="true" /&gt; &lt;!-- 设置自动启动 --&gt; &lt;property name="autoStartup" value="true" /&gt; &lt;!--&lt;property name="configLocation" value="classpath:quartz.properties" /&gt;--&gt;&lt;/bean&gt;&ensp;&ensp;&ensp;&ensp;dataSource用来配置数据源，数据表相关信息，可以到quartz官网下载gz包。面提供了主流数据库的sql文件，总共11张表，本例采用mysql数据库，表结构如下：tables_mysql.sql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168## Quartz seems to work best with the driver mm.mysql-2.0.7-bin.jar## PLEASE consider using mysql with innodb tables to avoid locking issues## In your Quartz properties file, you'll need to set# org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate#DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;DROP TABLE IF EXISTS QRTZ_LOCKS;DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;DROP TABLE IF EXISTS QRTZ_TRIGGERS;DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;DROP TABLE IF EXISTS QRTZ_CALENDARS;CREATE TABLE QRTZ_JOB_DETAILS ( SCHED_NAME VARCHAR(120) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, JOB_CLASS_NAME VARCHAR(250) NOT NULL, IS_DURABLE VARCHAR(1) NOT NULL, IS_NONCONCURRENT VARCHAR(1) NOT NULL, IS_UPDATE_DATA VARCHAR(1) NOT NULL, REQUESTS_RECOVERY VARCHAR(1) NOT NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP));CREATE TABLE QRTZ_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, NEXT_FIRE_TIME BIGINT(13) NULL, PREV_FIRE_TIME BIGINT(13) NULL, PRIORITY INTEGER NULL, TRIGGER_STATE VARCHAR(16) NOT NULL, TRIGGER_TYPE VARCHAR(8) NOT NULL, START_TIME BIGINT(13) NOT NULL, END_TIME BIGINT(13) NULL, CALENDAR_NAME VARCHAR(200) NULL, MISFIRE_INSTR SMALLINT(2) NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP) REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP));CREATE TABLE QRTZ_SIMPLE_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, REPEAT_COUNT BIGINT(7) NOT NULL, REPEAT_INTERVAL BIGINT(12) NOT NULL, TIMES_TRIGGERED BIGINT(10) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_CRON_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, CRON_EXPRESSION VARCHAR(200) NOT NULL, TIME_ZONE_ID VARCHAR(80), PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_SIMPROP_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, STR_PROP_1 VARCHAR(512) NULL, STR_PROP_2 VARCHAR(512) NULL, STR_PROP_3 VARCHAR(512) NULL, INT_PROP_1 INT NULL, INT_PROP_2 INT NULL, LONG_PROP_1 BIGINT NULL, LONG_PROP_2 BIGINT NULL, DEC_PROP_1 NUMERIC(13,4) NULL, DEC_PROP_2 NUMERIC(13,4) NULL, BOOL_PROP_1 VARCHAR(1) NULL, BOOL_PROP_2 VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_BLOB_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, BLOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_CALENDARS ( SCHED_NAME VARCHAR(120) NOT NULL, CALENDAR_NAME VARCHAR(200) NOT NULL, CALENDAR BLOB NOT NULL, PRIMARY KEY (SCHED_NAME,CALENDAR_NAME));CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP));CREATE TABLE QRTZ_FIRED_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, ENTRY_ID VARCHAR(95) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, FIRED_TIME BIGINT(13) NOT NULL, SCHED_TIME BIGINT(13) NOT NULL, PRIORITY INTEGER NOT NULL, STATE VARCHAR(16) NOT NULL, JOB_NAME VARCHAR(200) NULL, JOB_GROUP VARCHAR(200) NULL, IS_NONCONCURRENT VARCHAR(1) NULL, REQUESTS_RECOVERY VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,ENTRY_ID));CREATE TABLE QRTZ_SCHEDULER_STATE ( SCHED_NAME VARCHAR(120) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, LAST_CHECKIN_TIME BIGINT(13) NOT NULL, CHECKIN_INTERVAL BIGINT(13) NOT NULL, PRIMARY KEY (SCHED_NAME,INSTANCE_NAME));CREATE TABLE QRTZ_LOCKS ( SCHED_NAME VARCHAR(120) NOT NULL, LOCK_NAME VARCHAR(40) NOT NULL, PRIMARY KEY (SCHED_NAME,LOCK_NAME));commit;附：本次项目地址https://github.com/syshlang/syshlang-spring-quartz.git &ensp;&ensp;&ensp;&ensp;]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringQuartz</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令全集]]></title>
    <url>%2Ffe644125%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker从入门到实践]]></title>
    <url>%2Fc1109852%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>technology</category>
        <category>Container</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web应用安全之SQL注入]]></title>
    <url>%2F7443f4e%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;最近，在做一个项目，当项目完成交付时，银行客户对我们的产品安全提出了质疑，要求我们对产品系统进行安全检测，应要求我们利用IBM AppScan 安全扫描工具进行了扫描，经过扫描我们发现系统存在一些SQL注入、XSS攻击等安全漏洞。我们在开发web应用的过程中，对于项目DAO层的SQL非法注入问题是我们经常会考虑的web安全隐患之一。作为一个从业多年的Java web应用开发者，本文将从java的角度来说说开发过程中的SQL注入的问题。什么是SQL注入&ensp;&ensp;&ensp;&ensp;所谓SQL注入，就是攻击者恶意将SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串,这样当应用程序向后台数据库进行SQL查询时，以“欺骗”服务器执行非法的SQL命令，最终致使攻击者非法数据侵入系统。现在我们通过一个简单的项目演示攻击者利用SQL注入非法入侵系统。SQL注入演示环境搭建&ensp;&ensp;&ensp;&ensp;采用Mysql新建用户表，并搭建一个web项目。SYS_USER123456789101112131415-- ------------------------------ Table structure for `SYS_USER`-- ----------------------------DROP TABLE IF EXISTS `SYS_USER`;CREATE TABLE `SYS_USER` ( `id` int(11) NOT NULL AUTO_INCREMENT, `account` varchar(50) NOT NULL COMMENT '登录名', `password` varchar(100) NOT NULL COMMENT '密码(加密)', `lastLoginIp` varchar(20) DEFAULT NULL COMMENT '最后登录IP', `lastLoginTime` datetime DEFAULT NULL COMMENT '最后登录时间', `loginCount` int(11) NOT NULL COMMENT '登录总次数', `createTime` datetime NOT NULL COMMENT '创建时间', `isEnable` int(1) NOT NULL COMMENT '是否启用', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COMMENT='用户表';并插入数据,如下：controller层提供一个查询用户列表的接口（RESTFu风格）UserController.java12345678910111213141516171819202122@Path("/user")@Transactional@Component@Slf4jpublic class UserController &#123; @Autowired private UserDao userDao; @Resource(name = "myDataSource") private DataSource myDataSource; @GET @Path("/list") @Produces(MediaType.APPLICATION_JSON) public Response getUserList(@QueryParam("account") String account)&#123; //执行SQL,输出查到的数据 JdbcTemplate jdbcTemplate = new JdbcTemplate(myDataSource); String sql = "select * from sys_user where account ='"+account+"'"; List&lt;?&gt; resultList = jdbcTemplate.queryForList(sql); return Response.ok(resultList).build(); &#125;&#125;注入演示首先，我们在浏览器输入请求地址，发出请求，查询账户为admin的用户信息：GET&gt;http://localhost:8080/user/list?account=admin浏览器窗口正常返回结果：接着，我们在发出这样一个请求，如下GET&gt; http://localhost:8080/user/list?account=admin&#39; or ‘a’=’a浏览器窗口返回结果：此时我们发现，查出了所有的用户信息，仔细调试会发现执行了如下的sql1select * from sys_user where account ='admin' or 'a'='a'这是因为我们传入的参数account参数与我们接口中的查询语句进行拼接后构成了一条合法的SQL查询，这就是SQL注入。黑客往往就会通过传入精心构造的参数来进行SQL注入，非法入侵系统。SQL注入的防范与处理&ensp;&ensp;&ensp;&ensp;SQL注入原因就是由于传入的参数与系统的SQL拼接成了合法的SQL而导致的，而其本质还是将用户输入的数据当做了代码执行。了解了SQL注入的本质和原理，在Java web应用开发的过程中，我们如何防范和处理呢？JDBC的预处理&ensp;&ensp;&ensp;&ensp;Java的JDBC中，有个预处理功能，这个功能提供了PreparedStatement （预处理执行语句）的方式，SQL语句在程序运行前已经进行了预编译，在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库以参数化的形式进行查询，当运行时，动态地把参数传给PreprareStatement时，即使参数里有敏感字符,如 or ‘a=a’,数据库会将整个参数作为一个字段的属性值来处理而不会作为一个SQL指令，这样就在一定程度上预防了绝大多数的SQL注入。&ensp;&ensp;&ensp;&ensp;对刚才的代码做优化，采用预处理的方式，如下：UserController.java12345678910@GET @Path("/list") @Produces(MediaType.APPLICATION_JSON) public Response getUserListPreprareStatement(@QueryParam("account") String account)&#123; //执行SQL,输出查到的数据 JdbcTemplate jdbcTemplate = new JdbcTemplate(myDataSource); String sql = "select * from sys_user where account = ?"; List resultList = jdbcTemplate.queryForList(sql,account); return Response.ok(resultList).build(); &#125;&ensp;&ensp;&ensp;&ensp;此时，我们再采用刚才的SQL非法注入的方式访问，发现未查询出任何数据，说明SQL注入未成功，打印JDBC预处理后的SQL，发现所有的 ‘ 都被 \’ 转义掉了，从而防止了SQL注入。Mybatis下注入防范&ensp;&ensp;&ensp;&ensp;Mybatis框架作为一款半自动化的持久层框架，支持定制化 SQL、存储过程以及高级映射，其sql语句都要我们自己来手动编写，使用该框架时，防止SQL注入我们只需要弄清楚#{}和${}的区别以及order by注入问题。#{}：使用的是PreparedStatement，会有类型转换，比较安全；${}：使用字符串拼接，可以SQL注入；order by语句后不能用#{}，只能用${}，此时会存在SQL注入危险，需要手动处理；like查询不小心会有漏动，正确写法如下：123456--Mysql:select * from sys_user where account like concat('%', #&#123;account&#125;, '%') --Oracle: select * from sys_user where account like '%' || #&#123;account&#125; || '%' --SQLServer: select * from sys_user where account like '%' + #&#123;account&#125; + '%'自定义过滤规则防范注入&ensp;&ensp;&ensp;&ensp;由于动态SQL语句是引发SQL注入的根源。因此，开发过程中我们应尽量使用预编译语句来组装SQL查询，并且，随着ORM技术的发展，很多ORM框架在安全问题上都有进行处理，只要我们按照规范，基本上可以很大程度的消除SQL注入的风险。但是，在必要情况下，我们还需通过自定义过滤规则的方式来防范SQL注入。就Java web而言，我们可以通过在后台添加自定义的过滤器（Filter），对每个请求的参数过滤一些关键字，替换成安全的，从而解决注入问题，步骤如下在后台添加自定义的过滤器,对每个请求进行过滤SqlFilter.java1234567891011121314151617public class SqlFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //在Filter里面调用自定义的HttpServletRequestWrapper filterChain.doFilter(new SqlHttpServletRequestWrapper((HttpServletRequest) servletRequest), servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125;实现一个自定义的HttpServletRequestWrapper，然后在Filter里面调用它,重写getParameter方法SqlHttpServletRequestWrapper.java123456789101112131415161718192021222324252627282930313233343536public class SqlHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; public SqlHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; /** * 重写getParameter方法 过滤一些关键字，替换成安全的 * @param s * @return */ @Override public String getParameter(String s) &#123; String parameter = super.getParameter(s); parameter = stripSqlInject(parameter); return parameter; &#125; /** * 对每个请求的参数过滤一些关键字，替换成安全的 * @param parameter * @return */ private String stripSqlInject(String parameter) &#123; if(!StringUtils.isEmpty(parameter)) &#123; //干掉or 攻击 parameter=parameter.replaceAll("(?i)\\w*\\s*((\\%27)|(\\'))\\s*((\\%6F)|o|(\\%4F))((\\%72)|r|(\\%52))", ""); //干掉union 攻击 parameter=parameter.replaceAll("(?i)\\w*\\s*((\\%27)|(\\'))\\s*union", ""); //干掉截断攻击--原理：通过注释符号来截断后面的查询条件 parameter=parameter.replaceAll("(?i)\\s*((\\%27)|(\\'))[\\s\\S^-]*--\\s*[and|exec|execute|insert|select|delete|" + "update|count|drop|truncate|information_schema.columns|table_schema|union]*", ""); &#125; return parameter; &#125;&#125;在web.xml中配置过滤器web.xml123456789&lt;filter&gt; &lt;filter-name&gt;SqlFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.syshlang.framework.filter.SqlFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;SqlFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt;附：本次演示的项目地址https://github.com/syshlang/syshlang-injection-demo]]></content>
      <categories>
        <category>technology</category>
        <category>Safety</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>web</tag>
        <tag>injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 思维导图]]></title>
    <url>%2Faedf899f%2F</url>
    <content type="text"><![CDATA[JavaScript变量JavaScript运算符JavaScript数组JavaScript流程语句JavaScript字符串函数JavaScript函数基础JavaScript基础DOM操作JavaScript DOM对象JavaScript BOM浏览器对象模型JavaScript 正则表达式]]></content>
      <categories>
        <category>technology</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(九)]]></title>
    <url>%2Fcc2e58d0%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(八)用户和权限管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- root密码重置1. 停止MySQL服务2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables3. use mysql;4. UPDATE `user` SET PASSWORD=PASSWORD("密码") WHERE `user` = "root";5. FLUSH PRIVILEGES;用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES;-- 增加用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 'user_name'@'192.168.1.1' - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码-- 删除用户DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO 'pms'@'%' IDENTIFIED BY 'pms0817';-- 查看权限SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限-- 权限层级-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限表维护1234567-- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...杂项可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！每个库目录存在一个保存当前数据库的选项文件db.opt。注释：单行注释 # 注释内容多行注释 /* 注释内容 */单行注释 - - 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)模式通配符：_ 任意单个字符% 任意多个字符，甚至包括零字符单引号需要进行转义 \’CMD命令行内的语句结束符可以为 “;”, “\G”, “\g”，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。SQL对大小写不敏感清除已有语句：\c]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(八)]]></title>
    <url>%2Fd0ffb234%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(七)内置函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end 多分支if(expr1,expr2,expr3) 双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();自定义函数1234567891011121314151617--// 存储函数，自定义函数 ------------ 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由"参数名"和"参数类型"组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。-- 删除 DROP FUNCTION [IF EXISTS] function_name;-- 查看 SHOW FUNCTION STATUS LIKE 'partten' SHOW CREATE FUNCTION function_name;-- 修改 ALTER FUNCTION function_name 函数选项自定义功能12345678910111213141516171819202122232425262728293031--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建CREATE PROCEDURE sp_name (参数列表) 过程体参数列表：不同于函数的参数列表，需要指明参数类型IN，表示输入型OUT，表示输出型INOUT，表示混合型注意，没有返回值。/* 存储过程 */ ------------------存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：CALL 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出-- 语法CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END⇨ MySQL使用笔记(九)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(七)]]></title>
    <url>%2F19ad0d38%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(六)字符连接函数12concat(str1,str2,...])concat_ws(separator,str1,str2,...)sql语句123456789101112131415161718192021222324252627-- 分支语句if 条件 then 执行语句elseif 条件 then 执行语句else 执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号 SQL语句自定义结束符号delimiter ; -- 修改回原来的分号-- 语句块包裹begin 语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insertSQL编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051--// 局部变量 ------------ 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10; - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then statement_list [elseif search_condition then statement_list]...[else statement_list]end if;-- case语句CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END-- while循环[begin_label:] while search_condition do statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环⇨ MySQL使用笔记(八)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(六)]]></title>
    <url>%2F86a515b2%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(五)视图什么是视图：视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。视图具有表结构文件，但不存在数据文件。对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。123456789101112131415161718192021222324-- 创建视图CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数-- 查看结构 SHOW CREATE VIEW view_name-- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ...-- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement-- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构-- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。事务(transaction)123456789101112131415161718192021222324252627282930313233343536373839404142434445事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。-- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。-- 事务提交 COMMIT;-- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。-- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点-- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)锁表123456表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁-- 锁定 LOCK TABLES tbl_name [AS alias]-- 解锁 UNLOCK TABLES触发器1234567891011121314151617181920 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。-- 创建触发器CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构-- 删除DROP TRIGGER [schema_name.]trigger_name可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new.-- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。⇨ MySQL使用笔记(七)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(五)]]></title>
    <url>%2F1faa5dc0%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(四)连接查询(join)123456789101112131415161718192021222324将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2;-- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;导出1234567891011121314151617181920select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理-- 控制格式fields 控制字段格式默认：fields terminated by '\t' enclosed by '' escaped by '\\' terminated by 'string' -- 终止 enclosed by 'char' -- 包裹 escaped by 'char' -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE '/tmp/result.text' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n' FROM test_table;lines 控制行格式默认：lines terminated by '\n' terminated by 'string' -- 终止INSERT1234567891011121314select语句获得的数据可以用insert插入。可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...；可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), ();可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now());可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT);可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...;可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;DELETE123456DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]按照条件删除。where指定删除的最多记录数。limit可以通过排序条件删除。order by + limit支持多表删除，使用类似连接语法。delete from 需要删除数据多表1，表2 using 表连接操作 条件。TRUNCATE12345678TRUNCATE [TABLE] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区备份与还原1234567891011121314151617181920备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database DB1 [DB2 DB3...]mysqldump [options] --all--database1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)可以-w携带WHERE条件-- 导入1. 在登录mysql的情况下： source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件⇨ MySQL使用笔记(六)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(四)]]></title>
    <url>%2F14a2e4fb%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(三)建表规范Normal Format, NF每个表保存一个实体信息每个具有一个ID字段作为主键ID主键 + 原子表1NF, 第一范式字段不能再分，就满足第一范式。2NF, 第二范式满足第一范式的前提下，不能出现部分依赖。消除符合主键就可以避免部分依赖。增加单列关键字。3NF, 第三范式满足第二范式的前提下，不能出现传递依赖。某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。将一个实体信息的数据放在一个表内实现。SELECT1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb;b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录UNION1234567将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。子查询12345678910111213141516171819202122232425262728 - 子查询需用括号包裹。-- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。⇨ MySQL使用笔记(五)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(三)]]></title>
    <url>%2F63a5d46d%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(二)选择类型PHP角度功能满足存储空间尽量小，处理效率更高考虑兼容问题IP存储只需存储，可用字符串如果需计算，查找等，可存储为4个字节的无符号int，即unsignedPHP函数转换ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。利用sprintf函数格式化字符串sprintf(“%u”, ip2long(‘192.168.3.134’));然后用long2ip将整型转回IP字符串MySQL函数转换(无符号整型，UNSIGNED)INET_ATON(‘127.0.0.1’) 将IP转为整型INET_NTOA(2130706433) 将整型转为IP列属性（列约束）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, 'val'); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, 'val'); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. COMMENT 注释 例：create table tab ( id int ) comment '注释内容';7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。⇨ MySQL使用笔记(四)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(二)]]></title>
    <url>%2Ffaac85d7%2F</url>
    <content type="text"><![CDATA[⇦ MySQL使用笔记(一)数据操作12345678910111213141516-- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]-- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段-- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部-- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]字符集编码1234567891011121314151617-- MySQL、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致SHOW VARIABLES LIKE 'character_set_%' -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置-- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern'] 查看所有字符集 SHOW COLLATION [LIKE 'pattern'] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码数据类型（列类型）数值类型a. 整型类型字节范围（有符号位）tinyint1字节-128 ~ 127 无符号位：0 ~ 255smallint2字节-32768 ~ 32767mediumint3字节-8388608 ~ 8388607int4字节bigint8字节int(M) M表示总位数默认存在符号位，unsigned 属性修改显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改例：int(5) 插入一个数’123’，补填后为’00123’在满足要求的情况下，越小越好。1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用 tinyint(1)表示布尔型。b. 浮点型类型字节范围float(单精度)4字节double(双精度)8字节浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。不同于整型，前后均会补填0.定义浮点型时，需指定总位数和小数位数。float(M, D) double(M, D)M表示总位数，D表示小数位数。M和D的大小会决定浮点数的范围。不同于整型的固定范围。M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。支持科学计数法表示。浮点数表示近似值。c. 定点数decimal – 可变长度decimal(M, D) M也表示总位数，D表示小数位数。保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。将浮点数转换为字符串来保存，每9位数字保存为4个字节。字符串类型a. char, varcharchar 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3 b. blob, textblob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 c. binary, varbinary类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 日期时间类型一般用整型保存时间戳，可以很方便的将时间戳进行格式化。类型字节日期/时间范围datetime8字节日期及时间1000-01-01 00:00:00 到 9999-12-31 23:59:59date3字节日期1000-01-01 到 9999-12-31timestamp4字节时间戳19700101000000 到 2038-01-19 03:14:07time3字节时间-838:59:59 到 838:59:59year1字节年份1901 - 2155datetimeYYYY-MM-DD hh:mm:sstimestampYY-MM-DD hh:mm:ss / YYYYMMDDhhmmss / YYMMDDhhmmss / YYYYMMDDhhmmss / YYMMDDhhmmssdateYYYY-MM-DD / YY-MM-DD / YYYYMMDD / YYMMDD / YYYYMMDD / YYMMDDtimehh:mm:ss / hhmmss / hhmmssyearYYYY / YY / YYYY / YY枚举和集合枚举(enum)enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。 集合（set）123set(val1, val2, val3...)create table tab ( gender set('男', '女', '无') );insert into tab values ('男, 女');最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 ⇨ MySQL使用笔记(三)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用笔记(一)]]></title>
    <url>%2F77d59a46%2F</url>
    <content type="text"><![CDATA[Windows服务1234-- 启动MySQL net start mysql-- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)连接与断开服务器1234mysql -h 地址 -P 端口 -u 用户名 -p 密码SHOW PROCESSLIST -- 显示哪些线程正在运行SHOW VARIABLES -- 显示系统变量信息数据库操作123456789101112131415161718-- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE 'PATTERN']-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容表的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = '目录' -- 索引文件目录 INDEX DIRECTORY = '目录' -- 表注释 COMMENT = 'string' -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE 'pattern'] SHOW TABLES FROM 表名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN'] SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...⇨ MySQL使用笔记(二)]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>Mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 进阶]]></title>
    <url>%2F88f4aef3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle使用笔记]]></title>
    <url>%2F92d20082%2F</url>
    <content type="text"><![CDATA[Linux系统下启动Oracle数据库步骤第一步：打开Oracle监听1[root@sunys ~]# lsnrctl start第二步：进入sqlplus1[root@sunys ~]# sqlplus /nolog第三步：使用sysdab角色登录sqlplus1SQL&gt; conn /as sysdba第四步：启动数据库1SQL&gt; startup&ensp;&ensp;&ensp;&ensp;&ensp;经过上面的四个步骤，oracle数据库就可以启动了;关闭数据库用 shutdown 是要等待事物结束才关闭，强制关闭用 shutdown abort。修改Oracle数据库表空间自增长1234select * from dba_data_files; --查询表空间地址ALTER DATABASE DATAFILE '/oradata/twcwfntts.dbf' AUTOEXTEND ON; --打开自动增长ALTER DATABASE DATAFILE '/oradata/twcwfntts.dbf' AUTOEXTEND ON NEXT 200M ; --每次自动增长200mALTER DATABASE DATAFILE '/oradata/twcwfntts.dbf' AUTOEXTEND ON NEXT 200M MAXSIZE 2024M; --每次自动增长200m，数据表最大不超过1G使用listagg()和WITHIN GROUP ()将多行合并成一行1234567select a.id, a.name, (select listagg(b.name, ',') within group(order by b.id) from t_sm_line b where a.exc_line like b.id||',%' or a.exc_line like '%,'||b.id||',%' or a.exc_line like '%,'||b.id or a.exc_line = cast(a.id as varchar(10)) or instr(b.id,a.exc_line) &gt;0) exc_linefrom t_sm_line a where a.exc_line is not null]]></content>
      <categories>
        <category>technology</category>
        <category>database</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>database</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Shiro框架之授权]]></title>
    <url>%2Fd533dab%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;在应用系统中，对于不同角色的用户而言，在系统中的操作权限，例如，对于超级管理员角色可以操作所有功能，普通用户只能访问部分功能，这就是所谓的授权，也叫访问控制，即在应用中控制谁访问哪些资源（如访问页面/编辑数据/页面操作等）。shiro中授权的核心&ensp;&ensp;&ensp;&ensp;在shiro授权中，最核心的是：主体/用户（Subject）、权限（Permission）、角色（Role）、资源（Resource）,通过这几个关键对象，Shiro可以支持粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权限，即实例级别的）。主体(Subject)：访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权后才允许访问相应的资源。资源(Resource)：在应用中用户可以访问的 URL，比如访问 JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。权限(Permission)：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）等。权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许。角色(Role)：权限的集合，一般情况下会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。Shiro三种授权方式编程式通过写if/else 授权代码块完成1234567 Subject currentUser = SecurityUtils.getSubject();// 测试是否有某一个角色. 调用 Subject 的 hasRole 方法.if (currentUser.hasRole("admin")) &#123; //有权限&#125; else &#123; //无权限&#125;注解式通过在执行的Java方法上放置相应的注解完成，没有权限将抛出相应的异常12345678910/** * @author sunys */public class ShiroService &#123; @RequiresRoles(&#123;"admin"&#125;) public void testMethod()&#123; //有权限 &#125;&#125;权限注解@RequiresAuthentication：表示当前Subject已经通过 login进行了身份验证；即 Subject. isAuthenticated()返回 true；@RequiresUser：表示当前 Subject已经身份验证或者通过记 住我登录的；@RequiresGuest：表示当前Subject没有身份验证或通过记住我登录过，即是游客身份；@RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)：表示当前 Subject 需要角色 admin 和user；@RequiresPermissions(value={“user:a”, “user:b”}, logical= Logical.OR)：表示当前 Subject需要权限 user:a或 user:b。JSP/GSP 标签在JSP/GSP页面通过相应的标签完成12345&lt;%--Jsp页面引入shiro标签库--%&gt;&lt;%@ tagliburi="http://shiro.apache.org/tags" prefix="shiro" %&gt;&lt;shiro:hasRole name="admin"&gt; &lt;!— 有权限 —&gt; &lt;/shiro:hasRole&gt;Shiro 提供了 JSTL 标签用于在 JSP 页面进行权限控制标签名称及标签条件（均是显示标签内容）含义举例&lt;shiro:authenticated&gt;用户已经身份验证通过，即 Subject.login登录成功，不是记住我登录的&lt;shiro:notAuthenticated&gt;用户未进行身份验证，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证&lt;shiro:guest&gt;用户没有身份验证时显示相应信息，即游客访问信息&lt;shiro:user&gt;用户已经经过认证/记住我登录后显示相应的信息&lt;shiro:hasAnyRoles name=”abc,123”&gt;在有abc或者123角色时&lt;shiro:hasRole name=”abc”&gt;拥有角色abc&lt;shiro:lacksRole name=”abc”&gt;没有角色abc&lt;shiro:hasPermission name=”abc”&gt;拥有权限资源abc&lt;shiro:lacksPermission name=”abc”&gt;没有abc权限资源&lt;shiro:principal&gt;显示用户身份名称&lt;shiro:principal property=”username”/&gt;显示用户身份信息，默认调用 Subject.getPrincipal()获取，即 Primary Principal。Shiro 授权流程授权流程首先调用 Subject.isPermitted*/hasRole* 接口，其会委托给SecurityManager，而 SecurityManager接着会委托给 Authorizer；Authorizer是真正的授权者，如果调用如 isPermitted(“user:view”)，其首先会通过 PermissionResolver把字符串转换成相应的 Permission实例；在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限；Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果 有多个Realm，会委托给ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted*/hasRole* 会返回true，否则返回false表示授权失败。PermissionsShiro 的 Permissions规则：&ensp;&ensp;&ensp;&ensp;资源标识符：操作：对象实例 ID 即对哪个资源的哪个实例可以进行什么操作. 其默认支持通配符权限字符串；: 表示资源/操作/实例的分割；, 表示操作的分割，* 表示任意资源/操作/实例。多层次管理：&ensp;&ensp;&ensp;&ensp;例如：user:query、user:edit冒号是一个特殊字符，它用来分隔权限字符串的下一部件：第一部分 是权限被操作的领域（打印机），第二部分是被执行的操作;多个值：每个部件能够保护多个值。因此，除了授予用户 user:query 和 user:edit 权限外，也可以简单地授予他们一个：user:query, edit;还可以用 * 号代替所有的值，如：user:* ， 也可以写：*:query，表示某个用户在所有的领域都有 query 的权限。实例级访问控制：这种情况通常会使用三个部件：域、操作、被付诸实施的实例。如：user:edit:manager；也可以使用通配符来定义，如：user:edit:*、user:*:*、user:*:manager;部分省略通配符：缺少的部件意味着用户可以访问所有与之匹配的值，比如：user:edit 等价于 user:edit :*、 user 等价于 user:*:*;注意：通配符只能从字符串的结尾处省略部件，也就是说 user:edit 并不等价于 user:*:editModularRealmAuthorizerModularRealmAuthorizer 进行多 Realm 匹配流程：首先检查相应的 Realm 是否实现了实现了Authorizer；如果实现了 Authorizer，那么接着调用其相应的 isPermitted*/hasRole* 接口进行匹配；如果有一个Realm匹配那么将返回 true，否则返回 false。附：授权相关的的拦截器及其他]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Shiro</tag>
        <tag>Authorization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Shiro框架之认证]]></title>
    <url>%2F159c7b0e%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;在应用系统中，对于用户而言，登录系统时，一般需要提供如身份 ID等一些标识信息来表明登录者的身份，如提供 email，用户名/密码来证明，这就是所谓的身份验证；对于服务端，需要先收集用户（对应Shiro中的Subject）提供的 principals（身份）和 credentials（证明）并进行进行身份确认，这就是所谓的认证。身份验证&ensp;&ensp;&ensp;&ensp;在 shiro 中，用户需要提供 principals （身份）和 credentials（证 明）给 shiro，从而应用能验证用户身份：principals：身份，即主体的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个Primary principals，一般是用户名/邮箱/手机号。credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。最常见的 principals 和 credentials 组合就是用户名/密码了。身份验证基本流程收集用户身份/凭证，即如用户名/密码;调用 Subject.login 进行登录，如果失败将得到相应的 AuthenticationException异常，根据异常提示用户 错误信息；否则登录成功;创建自定义的 Realm类，继承 org.apache.shiro.realm.AuthorizingRealm类，实现 doGetAuthenticationInfo()方法;如果身份验证失败请捕获 AuthenticationException或其子类。示例：ShiroHandler.javaShiroHandler.java123456789101112131415161718192021222324252627282930/** * @author sunys */@Controller@RequestMapping("/shiro")public class ShiroHandler &#123; @RequestMapping("/login") public String login(@RequestParam("username") String username, @RequestParam("password") String password) &#123; Subject currentUser = SecurityUtils.getSubject(); if (!currentUser.isAuthenticated()) &#123; // 把用户名和密码封装为 UsernamePasswordToken 对象 UsernamePasswordToken token = new UsernamePasswordToken(username, password); // rememberme token.setRememberMe(true); try &#123; // 执行登录. currentUser.login(token); &#125; // ... catch more exceptions here (maybe custom ones specific to your application? // 所有认证时异常的父类. catch (AuthenticationException ae) &#123; //unexpected condition? error? System.out.println("登录失败: " + ae.getMessage()); &#125; &#125; return "redirect:/list.jsp"; &#125;&#125;ShiroRealm.javaShiroRealm.java1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @author sunys */public class ShiroRealm extends AuthorizingRealm &#123; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //1. 把 AuthenticationToken 转换为 UsernamePasswordToken UsernamePasswordToken upToken = (UsernamePasswordToken) token; //2. 从 UsernamePasswordToken 中来获取 username String username = upToken.getUsername(); //3. 调用数据库的方法, 从数据库中查询 username 对应的用户记录 System.out.println("从数据库中获取 username: " + username + " 所对应的用户信息."); //4. 若用户不存在, 则可以抛出 UnknownAccountException 异常 if("unknown".equals(username))&#123; throw new UnknownAccountException("用户不存在!"); &#125; //5. 根据用户信息的情况, 决定是否需要抛出其他的 AuthenticationException 异常. if("monster".equals(username))&#123; throw new LockedAccountException("用户被锁定"); &#125; //6. 根据用户的情况, 来构建 AuthenticationInfo 对象并返回. 通常使用的实现类为: SimpleAuthenticationInfo //以下信息是从数据库中获取的. //1). principal: 认证的实体信息. 可以是 username, 也可以是数据表对应的用户的实体类对象. Object principal = username; //2). credentials: 密码. Object credentials = null; //"fc1709d0a95a6be30bc5926fdb7f22f4"; if("admin".equals(username))&#123; credentials = "038bdaf98f2037b31f1e75b5b4c9b26e"; &#125;else if("user".equals(username))&#123; credentials = "098d2c478e9c11555ce2823231e02ec1"; &#125; //3). realmName: 当前 realm 对象的 name. 调用父类的 getName() 方法即可 String realmName = getName(); //4). 盐值. ByteSource credentialsSalt = ByteSource.Util.bytes(username); SimpleAuthenticationInfo info = null; //new SimpleAuthenticationInfo(principal, credentials, realmName); info = new SimpleAuthenticationInfo(principal, credentials, credentialsSalt, realmName); return info; &#125;&#125; 身份认证身份认证流程首先调用 Subject.login(token)进行登录，其会自动委托给 SecurityManager;SecurityManager负责真正的身份验证逻辑；它会委托给 Authenticator进行身份验证；Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；Authenticator可能会委托给相应的 AuthenticationStrategy进行多 Realm身份验证，默认 ModularRealmAuthenticator会调用AuthenticationStrategy进行多 Realm身份验证；Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处 可以配置多个Realm，将按照相应的顺序及策略进行访问。Authenticator&ensp;&ensp;&ensp;&ensp;Authenticator的职责是验证用户帐号，是 Shiro API中身份验证核心的入口点：如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败将抛出相应的 AuthenticationException异常。&ensp;&ensp;&ensp;&ensp;SecurityManager接口继承了 Authenticator，另外还有一个 ModularRealmAuthenticator实现，其委托给多个Realm进行验证，验证规则通过 AuthenticationStrategy接口指定。Realm&ensp;&ensp;&ensp;&ensp;Shiro从 Realm获取安全数据（如用户、角色、 权限），即 SecurityManager要验证用户身份，那么它需要从 Realm获取相应的用户进行比较以确定用户身份是否 合法；也需要从 Realm得到用户相应的角色/权限进行验证用户是否能进行操作，可以有一个或多个 Realm，将按照相应的顺序及策略进行访问。1234567891011121314151617181920212223242526272829&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realms"&gt; &lt;list&gt; &lt;!-- 配置多个Realm ，采用不同的加密方式，将按照list相应的顺序--&gt; &lt;ref bean="firstRealm"/&gt; &lt;ref bean="secondRealm"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="firstRealm" class="com.syshlang.shiro.realms.ShiroRealm"&gt; &lt;!-- 配置凭证算法匹配器 --&gt; &lt;property name="credentialsMatcher"&gt; &lt;bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;!-- 采用MD5加密--&gt; &lt;property name="hashAlgorithmName" value="MD5"&gt;&lt;/property&gt; &lt;property name="hashIterations" value="1024"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="secondRealm" class="com.syshlang.shiro.realms.SecondRealm"&gt; &lt;!-- 配置凭证算法匹配器 --&gt; &lt;property name="credentialsMatcher"&gt; &lt;bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;!-- 采用SHA1加密--&gt; &lt;property name="hashAlgorithmName" value="SHA1"&gt;&lt;/property&gt; &lt;property name="hashIterations" value="1024"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;Realm接口如下：String getName();//返回一个唯一的Realm名字boolean supports(AuthenticationToken token);//判断此Realm是否支持TokenAuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;//根据Token获取认证信息&ensp;&ensp;&ensp;&ensp;实际开发中，一般继承 AuthorizingRealm（授权）即可；其继承了 AuthenticatingRealm（即身份验证），而且也间接继承了CachingRealm（带有缓存实现）。Realm 的继承关系：AuthenticationStrategyAllSuccessfulStrategy：所有Realm验证成功才算成功，且返回所有 Realm身份验证成功的认证信息，如果有一个失败就失败了；AtLeastOneSuccessfulStrategy：只要有一个Realm验证成功即可，和 FirstSuccessfulStrategy不同，将返回所有 Realm身份验证成功的认证信 息；FirstSuccessfulStrategy：只要有一个 Realm 验证成功即可，只返回第一个 Realm身份验证成功的认证信息，其他的忽略。ModularRealmAuthenticator 默认是 AtLeastOneSuccessfulStrategy策略：1234//ModularRealmAuthenticator默认构造器 public ModularRealmAuthenticator() &#123; this.authenticationStrategy = new AtLeastOneSuccessfulStrategy(); &#125;自定义配置ModularRealmAuthenticator，更改默认策略：12345&lt;bean id="authenticator" class="org.apache.shiro.authc.pam.ModularRealmAuthenticator"&gt; &lt;property name="authenticationStrategy"&gt; &lt;bean class="org.apache.shiro.authc.pam.FirstSuccessfulStrategy"&gt;&lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;附：身份验证相关的拦截器]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Shiro</tag>
        <tag>Authenticator</tag>
        <tag>Realm</tag>
        <tag>AuthenticationStrategy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Shiro框架与Web集成]]></title>
    <url>%2F54c6b908%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;在《Apache Shiro框架》中提到，Apache Shiro是 Java 的一个强大易用的安全（权限）框架，提供了认证、授权、加密、会话管理、与Web 集成、缓存等功能，本文主要记录本人在学习使用Apache Shiro框架与Web集成过程中一些总结及感悟，学习过程中通过新建项目边学边练来加深理解。与Web的集成&ensp;&ensp;&ensp;&ensp;Shiro 提供了与Web集成的支持，其通过一个ShiroFilter入口来拦截需要安全控制的URL，然后进行相应的控制。ShiroFilter类似于如 Strut2/SpringMVC这种web框架的前端控制器，是安全控制的入口点，其负责读取配置（如ini 配置文件），然后判断URL 是否需要登录/权限等工作。《Apache Shiro框架默认过滤器及URL匹配》对于Shiro框架默认过滤器及URL匹配做了详细的讲解。Shiro与Web的集成的配置详解配置Spring 及 SpringMVC&ensp;&ensp;&ensp;&ensp;Spring及SpringMVC配置此处略，详见《Apache SpringMvc配置详解及源码分析》。配置Shiro的SecurityManager&ensp;&ensp;&ensp;&ensp;securityManager安全管理器，它相当于SpringMVC 中的 DispatcherServlet；是Shiro的心脏所有具体的交互都通过SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证、授权、会话及缓存的管理，其配置如下：1234567891011&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="cacheManager" ref="cacheManager"/&gt; &lt;property name="authenticator" ref="authenticator"/&gt; &lt;property name="realms"&gt; &lt;list&gt; &lt;ref bean="jdbcRealm"/&gt; &lt;ref bean="secondRealm"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="rememberMeManager.cookie.maxAge" value="10"&gt;&lt;/property&gt;&lt;/bean&gt;配置CacheManager及authenticator&ensp;&ensp;&ensp;&ensp;CacheManager缓存控制器，用来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能；Authenticator负责 Subject 认证，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过了。12345678&lt;bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt; &lt;property name="cacheManagerConfigFile" value="classpath:ehcache.xml"/&gt;&lt;/bean&gt;&lt;bean id="authenticator" class="org.apache.shiro.authc.pam.ModularRealmAuthenticator"&gt; &lt;property name="authenticationStrategy"&gt; &lt;bean class="org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy"&gt;&lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;配置 Realm&ensp;&ensp;&ensp;&ensp;Shiro从Realm 获取安全数据（如用户、角色、权限），可以有一个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是内存实现等等；由用户提供；所以一般在应用中都需要实现自己的 Realm。1234567891011121314151617&lt;!-- 直接配置实现了 org.apache.shiro.realm.Realm 接口的 bean --&gt;&lt;bean id="jdbcRealm" class="com.syshlang.shiro.realms.ShiroRealm"&gt; &lt;property name="credentialsMatcher"&gt; &lt;bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;property name="hashAlgorithmName" value="MD5"&gt;&lt;/property&gt; &lt;property name="hashIterations" value="1024"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="secondRealm" class="com.syshlang.shiro.realms.SecondRealm"&gt; &lt;property name="credentialsMatcher"&gt; &lt;bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;property name="hashAlgorithmName" value="SHA1"&gt;&lt;/property&gt; &lt;property name="hashIterations" value="1024"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;配置LifecycleBeanPostProcessor&ensp;&ensp;&ensp;&ensp;LifecycleBeanPostProcessor将Initializable和Destroyable的实现类统一在其内部自动分别调用了Initializable.init()和Destroyable.destroy()方法，从而达到管理shiro bean生命周期的目的， 可以自定的来调用配置在Spring IOC容器中shiro bean的生命周期方法。1&lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt;启用IOC容器中使用shiro的注解&ensp;&ensp;&ensp;&ensp;启用IOC 容器中使用shiro的注解，但必须在配置了 LifecycleBeanPostProcessor 之后才可以使用。12345&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt;&lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt;&lt;/bean&gt;配置Shiro的shiroFilter&ensp;&ensp;&ensp;&ensp;Shiro的DefaultFilter在整个Shiro架构中的作用便是用来拦截所有请求。在 Shiro DefaultFilter 中我们配置了 filterChainDefinitions 属性。filterChainDefinitions 的作用便是对所有被Shiro 拦截的请求做声明，下面是一个标准的DefaultFilter和 filterChainDefinitions 的配置。12345678910111213141516171819202122232425262728&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;property name="successUrl" value="/list.jsp"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;property name="filterChainDefinitionMap" ref="filterChainDefinitionMap"&gt;&lt;/property&gt; &lt;!-- 配置哪些页面需要受保护. 以及访问这些页面需要的权限. 1). anon 可以被匿名访问 2). authc 必须认证(即登录)后才可能访问的页面. 3). logout 登出. 4). roles 角色过滤器 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /login.jsp = anon /shiro/login = anon /shiro/logout = logout /user.jsp = roles[user] /admin.jsp = roles[admin] # everything else requires authentication: /** = authc &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&ensp;&ensp;&ensp;&ensp;从以上的配置我们可以预见一个问题，那就是倘若filterChainDefinitions的声明过多的话会导致该配置文件冗余臃肿。在Shiro的源代码中filterChainDefinition本身是一个linkedHashMap，所以我们可以通过工厂设计模式来创建一个filterChainDefinitionMap。1234567891011121314&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;property name="successUrl" value="/list.jsp"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;property name="filterChainDefinitionMap" ref="filterChainDefinitionMap"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置一个 bean, 该 bean 实际上是一个 Map. 通过实例工厂方法的方式 --&gt;&lt;bean id="filterChainDefinitionMap" factory-bean="filterChainDefinitionMapBuilder" factory-method="buildFilterChainDefinitionMap"&gt;&lt;/bean&gt;&lt;bean id="filterChainDefinitionMapBuilder" class="com.syshlang.shiro.factory.FilterChainDefinitionMapBuilder"&gt;&lt;/bean&gt;FilterChainDefinitionMapBuilder.java12345678910111213141516/** * @author sunys */public class FilterChainDefinitionMapBuilder &#123; public LinkedHashMap&lt;String, String&gt; buildFilterChainDefinitionMap() &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); map.put("/login.jsp", "anon"); map.put("/shiro/login", "anon"); map.put("/shiro/logout", "logout"); map.put("/user.jsp", "authc,roles[user]"); map.put("/admin.jsp", "authc,roles[admin]"); map.put("/list.jsp", "user"); map.put("/**", "authc"); return map; &#125;&#125;&ensp;&ensp;&ensp;&ensp;在web.xml文件中配置Shiro的shiroFilter过滤器。web.xml12345678910111213&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&ensp;&ensp;&ensp;&ensp;DelegatingFilterProxy 实际上是 Filter 的一个代理对象，DelegatingFilterProxy 作用是自动到Spring IOC容器中查找名字为shiroFilter（filter-name）的bean并把所有Filter的操作委托给它，也可以通过targetBeanName 的初始化参数来配置filter bean 的id。&ensp;&ensp;&ensp;&ensp;因为Shiro会来IOC容器中查找和名字对应的 filter bean，所以配置Shiro的filter bean的id必须和 web.xml文件中配置的 DelegatingFilterProxy的一致，若不一致, 则会抛出: NoSuchBeanDefinitionException。&ensp;&ensp;&ensp;&ensp;shiro框架在Java Web应用中使用时，本质上是通过filter方式集成的。也就是说，它是遵循过滤器链规则的：filter的执行顺序与在web.xml中定义的顺序一致&ensp;&ensp;&ensp;&ensp;以上所涉及到的配置项在《Apache Shiro框架》中都有详细的讲解。附：配置清单applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="cacheManager" ref="cacheManager"/&gt; &lt;property name="authenticator" ref="authenticator"/&gt; &lt;property name="realms"&gt; &lt;list&gt; &lt;ref bean="jdbcRealm"/&gt; &lt;ref bean="secondRealm"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="rememberMeManager.cookie.maxAge" value="10"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt; &lt;property name="cacheManagerConfigFile" value="classpath:ehcache.xml"/&gt; &lt;/bean&gt; &lt;bean id="authenticator" class="org.apache.shiro.authc.pam.ModularRealmAuthenticator"&gt; &lt;property name="authenticationStrategy"&gt; &lt;bean class="org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="jdbcRealm" class="com.syshlang.shiro.realms.ShiroRealm"&gt; &lt;property name="credentialsMatcher"&gt; &lt;bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;property name="hashAlgorithmName" value="MD5"&gt;&lt;/property&gt; &lt;property name="hashIterations" value="1024"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="secondRealm" class="com.syshlang.shiro.realms.SecondRealm"&gt; &lt;property name="credentialsMatcher"&gt; &lt;bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;property name="hashAlgorithmName" value="SHA1"&gt;&lt;/property&gt; &lt;property name="hashIterations" value="1024"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;property name="successUrl" value="/list.jsp"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;property name="filterChainDefinitionMap" ref="filterChainDefinitionMap"&gt;&lt;/property&gt; &lt;!-- 配置哪些页面需要受保护. 以及访问这些页面需要的权限. 1). anon 可以被匿名访问 2). authc 必须认证(即登录)后才可能访问的页面. 3). logout 登出. 4). roles 角色过滤器 --&gt; &lt;!-- &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /login.jsp = anon /shiro/login = anon /shiro/logout = logout /user.jsp = roles[user] /admin.jsp = roles[admin] # everything else requires authentication: /** = authc &lt;/value&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; &lt;!-- 配置一个 bean, 该 bean 实际上是一个 Map. 通过实例工厂方法的方式 --&gt; &lt;bean id="filterChainDefinitionMap" factory-bean="filterChainDefinitionMapBuilder" factory-method="buildFilterChainDefinitionMap"&gt;&lt;/bean&gt; &lt;bean id="filterChainDefinitionMapBuilder" class="com.syshlang.shiro.factory.FilterChainDefinitionMapBuilder"&gt;&lt;/bean&gt; &lt;bean id="shiroService" class="com.syshlang.shiro.services.ShiroService"&gt;&lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Shiro</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Shiro框架默认过滤器及URL匹配]]></title>
    <url>%2F96db3174%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;shiro框架在Java Web应用中使用时，本质上是通过filter方式集成的，也就是说，它是遵循过滤器链规则，其通过一个ShiroFilter入口来拦截需要安全控制的URL，然后进行相应的控制，本文将对Shiro框架默认过滤器及URL匹配做讲解。Shiro框架默认过滤器ShiroFilter的工作原理&ensp;&ensp;&ensp;&ensp;filterChainDefinitions是ShiroFilter的属性，在filterChainDefinitions中可以对Url进行配置，看是否可以登录或安全权限的访问,详见后文。&ensp;&ensp;&ensp;&ensp;由上图可以看出：浏览器过来的任何请求都会先经过shiro先过滤，先到达AbstractShiroFilter.executeChain()方法，去根据request解析出来的url找到对应的过滤链，然后执行过滤器链，直到成功才会执行javaweb本身的过滤器。Shiro框架默认过滤器&ensp;&ensp;&ensp;&ensp;ShiroFilter拦截需要安全控制的URL，然后进行相应的控制,如果当前请求的url匹配 [urls]部分的某个url模式，将会执行其配置的拦截器，例如：anon（anonymous）拦截器表示匿名访问（即不需要登 录即可访问），authc （authentication）拦截器表示需要身份认证通过后才能访问。Shiro 内置了很多默认的拦截器，比如身份验证、授权等相关的。shiro框架内置一系列的过滤器供使用，如下：org.apache.shiro.web.filter.mgt.DefaultFilter.javashiro中默认的过滤器：&ensp;&ensp;&ensp;&ensp;这些过滤器分为两组，一组是认证过滤器，一组是授权过滤器，后面将会继续讲到。这些过滤器的API可以点击查看。实际开发中，我们可以自定义拦截器来扩展功能以满足项目需求，例如：动态url-角色/权限访问控制的实现、根据 Subject 身份信息获取用户信息绑定到 Request（即设置通用数据）、验证码验证、在线用户信息的保存等。Shiro框架URL匹配&ensp;&ensp;&ensp;&ensp;由于ShiroFilter通过拦截需要安全控制的URL进行相应的控制，urls可能是shiro中处理web项目比较核心的部分。RL配置格式[urls]部分的配置，其格式是：”url=拦截器[参数]，拦截器[参数]“URL匹配模式url 模式使用 Ant 风格模式;Ant 路径通配符支持 ?、*、**，注意通配符匹配不包括目录分隔符“/”：&ensp;&ensp;&ensp;&ensp;–?：匹配一个字符，如 /admin? 将匹配 /admin1，但不匹配 /admin 或 /admin/；&ensp;&ensp;&ensp;&ensp;–*：匹配零个或多个字符串，如 /admin 将匹配 /admin、/admin123，但不匹配 /admin/1；&ensp;&ensp;&ensp;&ensp;–**：匹配路径中的零个或多个路径，如 /admin/** 将匹配 /admin/a 或 /admin/a/b。URL 匹配顺序URL权限采取第一次匹配优先的方式，即从头开始使用第一个匹配的 url 模式对应的拦截器链。如：&ensp;&ensp;&ensp;&ensp;/bb/**=filter1&ensp;&ensp;&ensp;&ensp;/bb/aa=filter2&ensp;&ensp;&ensp;&ensp;/**=filter3&ensp;&ensp;&ensp;&ensp;如果请求的url是“/bb/aa”，因为按照声明顺序进行匹配，那么将使用 filter1 进行拦截。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Shiro</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Shiro框架]]></title>
    <url>%2F43930f47%2F</url>
    <content type="text"><![CDATA[概述&ensp;&ensp;&ensp;&ensp;Apache Shiro是 Java 的一个强大易用的安全（权限）框架，提供了认证、授权、加密、会话管理、与Web 集成、缓存等功能，可为任何应用提供安全保障，能非常容易的开发出足够好的应用，其不仅可以用在JavaSE 环境，也可以用在 JavaEE 环境。Shiro为解决下列问题提供了保护应用的API：认证 - 用户身份识别，常被称为用户“登录”；授权 - 访问控制；密码加密 - 保护或隐藏数据防止被偷窥；会话管理 - 每用户相关的时间敏感的状态。功能简介&ensp;&ensp;&ensp;&ensp;Apache Shiro基本功能点如图所示：Authentication : 身份认证/登录，验证用户是不是拥有相应的身份；Authorization : 授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用\户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户\对某个资源是否具有某个权限；Session Manager : 会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中,会话可以是普通 JavaSE 环境，也可以是 Web 环境的；Cryptography : 加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；Web Support : Web 支持，可以非常容易的集成到Web 环境；Caching : 缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；Concurrency : 多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；Testing : 提供测试支持；Run As : 允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；Remember Me : 记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了Shiro 架构Shiro外部来看&ensp;&ensp;&ensp;&ensp;从外部来看Shiro ，即从应用程序角度的来观察如何使用 Shiro 完成工作：Subject :应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外API 核心就是 Subject。Subject 代表了当前“用户”， 这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；与 Subject 的所有交互都会委托给 SecurityManager；Subject 其实是一个门面，SecurityManager 才是实际的执行者；SecurityManager : 安全管理器；即所有与安全有关的操作都会与SecurityManager 交互；且其管理着所有 Subject；可以看出它是 Shiro的核心，它负责与 Shiro 的其他组件进行交互，它相当于 SpringMVC 中DispatcherServlet 的角色；Realm :Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource。Shiro内部来看Subject :任何可以与应用交互的“用户”；SecurityManager :相当于SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证、授权、会话及缓存的管理。Authenticator :负责 Subject 认证，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过了；Authorizer :授权器、即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；Realm :可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC 实现，也可以是内存实现等等；由用户提供；所以一般在应用中都需要实现自己的 RealmSessionManager : 管理 Session 生命周期的组件；而 Shiro并不仅仅可以用在 Web环境，也可以用在如普通的 JavaSE 环境；CacheManager : 缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能；Cryptography : 密码模块，Shiro 提高了一些常见的加密组件用于如密码加密/解密。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Shiro</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringData组件之自定义Repository方法]]></title>
    <url>%2F8f305ba7%2F</url>
    <content type="text"><![CDATA[为某一个 Repository 上添加自定义方法1、定义一个接口: 声明要添加的, 并自实现的方法；PersonDao.javaPersonDao.java12345public interface PersonDao &#123; //自定义方法 void test(); &#125;2、提供该接口的实现类: 类名需在要声明的 Repository 后添加 Impl, 并实现方法；PersonRepsotoryImpl.javaPersonRepsotoryImpl.java1234567891011//规约：命名必须符合声明使用的 Repsotory 接口名 + Implpublic class PersonRepsotoryImpl implements PersonDao &#123; @PersistenceContext private EntityManager entityManager; @Override public void test() &#123; Person person = entityManager.find(Person.class, 11); System.out.println("--&gt;" + person); &#125;&#125;3、声明 Repository 接口, 并继承自定义的接口；PersonRepsotory.javaPersonRepsotory.java123public interface PersonRepsotory extends JpaRepository&lt;Person, Integer&gt;,PersonDao &#123;&#125;注意：默认情况下, Spring Data 会在 base-package 中查找 “接口名Impl” 作为实现类,也可以通过 repository-impl-postfix 声明后缀,如果有两个以上类名为PersonRepsotoryImpl的类，Spring Data Jpa会抛出错误。为所有的 Repository 都添加自实现的方法1、声明一个接口, 在该接口中声明需要自定义的方法, 且该接口需要继承 Spring Data 的 Repository；CommonMethod.javaCommonMethod.java123456@NoRepositoryBeanpublic interface CommonMethod&lt;T, ID extends Serializable&gt; extends JpaRepository&lt;T, ID&gt; &#123; void method();&#125;2、提供所声明的接口的实现类. 且继承 SimpleJpaRepository, 并提供方法的实现；CommonMethodImpl.javaCommonMethodImpl.java1234567891011121314@NoRepositoryBean CommonMethodImpl.javapublic class CommonMethodImpl&lt;T, ID extends Serializable&gt; extends SimpleJpaRepository&lt;T, ID&gt; implements CommonMethod&lt;T, ID&gt; &#123; public CommonMethodImpl(Class&lt;T&gt; domainClass, EntityManager em) &#123; super(domainClass, em); &#125; @Override public void method() &#123; System.out.println("...METHOD TEST..."); &#125;&#125;3、定义 JpaRepositoryFactoryBean 的实现类, 使其生成 1) 定义的接口实现类的对象；CommonJpaRepositoryFactoryBean.javaCommonJpaRepositoryFactoryBean.java12345678910111213141516171819202122232425262728public class CommonJpaRepositoryFactoryBean &lt;T extends Repository&lt;S, ID&gt;, S, ID extends Serializable&gt; extends JpaRepositoryFactoryBean&lt;T, S, ID&gt; &#123; protected RepositoryFactorySupport createRepositoryFactory( EntityManager entityManager) &#123; return new CommonRepositoryFactory(entityManager); &#125; private static class CommonRepositoryFactory&lt;T, I extends Serializable&gt; extends JpaRepositoryFactory &#123; private EntityManager entityManager; public CommonRepositoryFactory(EntityManager entityManager) &#123; super(entityManager); this.entityManager = entityManager; &#125; protected Object getTargetRepository(RepositoryMetadata metadata) &#123; return new CommonMethodImpl&lt;T, I&gt;( (Class&lt;T&gt;) metadata.getDomainType(), entityManager); &#125; protected Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) &#123; return CommonMethod.class; &#125; &#125;&#125;4、修改applicationContext.xml文件 &lt;jpa:repositories/&gt; 节点的 factory-class 属性指向CommonJpaRepositoryFactoryBean.java 的全类名；applicationContext.xmlapplicationContext.xml123456789... &lt;!-- base-package: 扫描 Repository Bean 所在的 package --&gt; &lt;jpa:repositories base-package="com.syshlang" entity-manager-factory-ref="entityManagerFactory" factory-class="com.syshlang.repository.common.impl.CommonJpaRepositoryFactoryBean"&gt; &lt;/jpa:repositories&gt;...注意：全局的扩展实现类不要用 Imp 作为后缀名, 或为全局扩展接口添加 @NoRepositoryBean 注解告知 Spring Data: Spring Data 不把其作为 Repository。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringData</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringData</tag>
        <tag>Repository</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringData组件之Repository接口方法定义规范]]></title>
    <url>%2F70fbc0d8%2F</url>
    <content type="text"><![CDATA[简单条件查询&ensp;&ensp;&ensp;&ensp;&ensp; 简单条件查询,查询某一个实体类或者集合,按照 Spring Data 的规范，查询方法以 find | read | get 开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写。&ensp;&ensp;&ensp;&ensp;&ensp; 例如：定义一个 Entity 实体类：1234class User&#123; private String firstName; private String lastName;&#125;&ensp;&ensp;&ensp;&ensp;&ensp; 使用And条件连接时，应这样写：12//条件的属性名称与个数要与参数的位置与个数一一对应findByLastNameAndFirstName(String lastName,String firstName);支持的关键字&ensp;&ensp;&ensp;&ensp;&ensp;直接在接口中定义查询方法，如果是符合规范的，可以不用写实现，目前支持的关键字写法如下：查询方法解析流程&ensp;&ensp;&ensp;&ensp;&ensp;假如创建查询：findByUserDepUuid()，假设查询实体为Doc，框架在解析该方法时，步骤如下：首先剔除 findBy，然后对剩下的属性进行解析；先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续下一步；从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复步骤，继续从右往左截取；最后假设 user 为查询实体的一个属性；接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照上一步骤的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询；可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_DepUuid()” 或者 “findByUserDep_uuid()”。即支持属性的级联查询， 若当前类有符合条件的属性, 则优先使用, 而不使用级联属性；若需要使用级联属性, 则属性之间使用 _ 进行连接。使用 @Query 注解使用@Query自定义查询&ensp;&ensp;&ensp;&ensp;&ensp;这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。例如：1234//查询 id 值最大的那个 Person//使用 @Query 注解可以自定义 JPQL 语句以实现更灵活的查询@Query("SELECT p FROM Person p WHERE p.id = (SELECT max(p2.id) FROM Person p2)")Person getMaxIdPerson();索引参数与命名参数索引参数如下所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致。123//为 @Query 注解传递参数的方式1: 使用占位符. @Query("SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2")List&lt;Person&gt; testQueryAnnotationParams1(String lastName, String email);命名参数（推荐使用这种方式）：可以定义好参数名，赋值时采用@Param(“参数名”)，而不用管顺序。123//为 @Query 注解传递参数的方式1: 命名参数的方式. @Query("SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email")List&lt;Person&gt; testQueryAnnotationParams2(@Param("email") String email, @Param("lastName") String lastName);如果是 @Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %1234567//SpringData 允许在占位符上添加 %%. @Query("SELECT p FROM Person p WHERE p.lastName LIKE %?1% OR p.email LIKE %?2%")List&lt;Person&gt; testQueryAnnotationLikeParam(String lastName, String email);//SpringData 允许在占位符上添加 %%. @Query("SELECT p FROM Person p WHERE p.lastName LIKE %:lastName% OR p.email LIKE %:email%")List&lt;Person&gt; testQueryAnnotationLikeParam2(@Param("email") String email, @Param("lastName") String lastName);还可以使用@Query来指定本地查询，只要设置nativeQuery为true，比如：123456//设置 nativeQuery=true 即可以使用原生的 SQL 查询@Query(value="SELECT count(id) FROM jpa_persons", nativeQuery=true)long getTotalCount();@Query(value="select * from tbl_user where name like %?1" ,nativeQuery=true)public List&lt;UserModel&gt; findByUuidOrAge(String name);@Modifying 注解和事务@Query 与 @Modifying 执行更新操作@Query 与 @Modifying 这两个 annotation一起声明，可定义个性化更新操作，例如只涉及某些字段更新时最为常用，示例如下：123456789101112/*** * 可以通过自定义的 JPQL 完成 UPDATE 和 DELETE 操作. 注意: JPQL 不支持使用 INSERT* 在 @Query 注解中编写 JPQL 语句, 但必须使用 @Modifying 进行修饰. 以通知 SpringData, 这是一个 * UPDATE 或 DELETE 操作* UPDATE 或 DELETE 操作需要使用事务, 此时需要定义 Service 层. 在 Service 层的方法上添加事务操作.* 默认情况下, SpringData 的每个方法上有事务, 但都是一个只读事务. 他们不能完成修改操作!*/@Modifying@Query("UPDATE Person p SET p.email = :email WHERE id = :id")void updatePersonEmail(@Param("id") Integer id, @Param("email") String email);注意：方法的返回值应该是 int，表示更新语句所影响的行数；在调用的地方必须加事务，没有事务不能正常执行事务Spring Data 提供了默认的事务处理方式，即所有的查询均声明为只读事务。对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上注解 @Transactional 声明 。进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，需要在 Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务。PersonRepsotory.javaPersonRepsotory.java123456789public interface PersonRepsotory extends JpaRepository&lt;Person, Integer&gt;, JpaSpecificationExecutor&lt;Person&gt;, PersonDao&#123; @Modifying @Query("UPDATE Person p SET p.email = :email WHERE id = :id") void updatePersonEmail(@Param("id") Integer id, @Param("email") String email);&#125;PersonService.javaPersonService.java1234567891011121314151617@Servicepublic class PersonService &#123; @Autowired private PersonRepsotory personRepsotory; @Transactional public void savePersons(List&lt;Person&gt; persons)&#123; personRepsotory.save(persons); &#125; @Transactional public void updatePersonEmail(String email, Integer id)&#123; personRepsotory.updatePersonEmail(id, email); &#125;&#125;]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringData</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringData</tag>
        <tag>Repository</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringData组件之Repository接口概述]]></title>
    <url>%2Fa6a04339%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;在《Spring框架组件之Spring Data》中,讲述Spring框架组件SpringData使用时提到了到Spring Data组件一个很重要的接口Repository接口，本篇文章在《Spring框架组件之Spring Data》的基础上着重讲述一下Repository接口。Repository 接口概述&ensp;&ensp;&ensp;&ensp;Repository 接口是 Spring Data的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法；1public interface Repository&lt;T, ID extends Serializable&gt; &#123; &#125;&ensp;&ensp;&ensp;&ensp;Spring Data可以让我们自定义接口，只要遵循 Spring Data的规范，就无需写实现类,例如：12public interface PersonRepsotory extends Repository&lt;Person,Integer&gt;&#123;&#125;&ensp;&ensp;&ensp;&ensp;与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。如下两种方式是完全等价的,如下图Repository 的子接口&ensp;&ensp;&ensp;&ensp;基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下：-Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类-CrudRepository&lt;：继承 Repository，实现了一组 CRUD 相关的方法-PagingAndSortingRepository：继承 CrudRepository，实现了一组分页排序相关的方法-JpaRepository：继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法-自定义的 XxxxRepository：需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力-JpaSpecificationExecutor：不属于Repository体系，实现一组 JPA Criteria 查询相关的方法。CrudRepository 接口&ensp;&ensp;&ensp;&ensp;CrudRepository 接口提供了最基本的对实体类的添删改查操作T save(T entity); //保存单个实体Iterablesave(Iterable&lt;? extends T&gt; entities);//保存集合T findOne(ID id);//根据id查找实体boolean exists(ID id);//根据id判断实体是否IterablefindAll();//查询所有实体,不用或慎用!long count();//查询实体数量void delete(ID id);//根据Id删除实体void delete(T entity);//删除一个实体void delete(Iterable&lt;? extends T&gt; entities);//删除一个实体的集合void deleteAll();//删除所有实体,不用或慎用!PagingAndSortingRepository接口&ensp;&ensp;&ensp;&ensp;该接口提供了分页与排序功能IterablefindAll(Sort sort);//排序PagefindAll(Pageable pageable);//分页查询（含排序功能）JpaRepository 接口&ensp;&ensp;&ensp;&ensp;该接口提供了JPA的相关功能ListfindAll();//查找所有实体ListfindAll(Sort sort);//排序、查找所有实体Listsave(Iterable&lt;? extends T&gt; entities);//保存集合void flush();//执行缓存与数据库同步T saveAndFlush(T entity);//强制执行持久化void deleteInBatch(Iterableentities);//删除一个实体集合JpaSpecificationExecutor接口&ensp;&ensp;&ensp;&ensp;该接口不属于Repository体系，它实现一组 JPA Criteria 查询相关的方法-Specification：封装 JPA Criteria 查询条件。通常使用匿名内部类的方式来创建该接口的对象自定义 Repository 方法&ensp;&ensp;&ensp;&ensp;为某一个 Repository 上添加自定义方法,详见《SpringData组件之自定义Repository方法》。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringData</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringData</tag>
        <tag>Repository</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架组件之Spring Data]]></title>
    <url>%2F8b6d97%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;本篇文章主要记录本人在学习使用Spring框架组件Spring Data的过程中一些总结及感悟，学习过程中通过新建项目边学边练来加深理解Spring Data 概述Spring Data是Spring 的一个子项目。用于简化数据库访问，支持NoSQL和关系数据存储 。其主要目标是使数据库的访问变得方便快捷。Spring Data 项目所支持NoSQL存储：&ensp;&ensp;&ensp;&ensp;-MongoDB （文档数据库）&ensp;&ensp;&ensp;&ensp;-Neo4j（图形数据库）&ensp;&ensp;&ensp;&ensp;-Redis（键/值存储）&ensp;&ensp;&ensp;&ensp;-Hbase（列族数据库）Spring Data 项目所支持的关系数据存储技术：&ensp;&ensp;&ensp;&ensp;-JDBC&ensp;&ensp;&ensp;&ensp;-JPA(本次采用)JPA Spring Data致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。搭建环境&ensp;&ensp;&ensp;&ensp;练习项目采用Maven+Spring Data，具体jar包及环境配置此处略，可参照Spring Data 、JPA进行持久层开发步骤&ensp;&ensp;&ensp;&ensp;&ensp;使用 Spring Data JPA 进行持久层开发需要的四个步骤：配置 Spring 整合 JPA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 1. 配置数据源 --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;!-- 配置其他属性 --&gt; &lt;/bean&gt; &lt;!-- 2. 配置 JPA 的 EntityManagerFactory --&gt; &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--jpa是是实现产品的适配器--&gt; &lt;property name="jpaVendorAdapter"&gt; &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;!--扫描加注解的包--&gt; &lt;property name="packagesToScan" value="com.syshlang"&gt;&lt;/property&gt; &lt;property name="jpaProperties"&gt; &lt;props&gt; &lt;!-- 二级缓存相关 --&gt; &lt;!-- &lt;prop key="hibernate.cache.region.factory_class"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/prop&gt; &lt;prop key="net.sf.ehcache.configurationResourceName"&gt;ehcache-hibernate.xml&lt;/prop&gt; --&gt; &lt;!-- 生成的数据表的列的映射策略 --&gt; &lt;prop key="hibernate.ejb.naming_strategy"&gt;org.hibernate.cfg.ImprovedNamingStrategy&lt;/prop&gt; &lt;!-- hibernate 基本属性 --&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 3. 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt; &lt;property name="entityManagerFactory" ref="entityManagerFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4. 配置支持注解的事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;在Spring 配置文件中配置 Spring Data&ensp;&ensp;&ensp;&ensp;在Spring 配置文件中配置 Spring Data，让Spring为声明的接口创建代理对象。配置了 &lt;jpa:repositories&gt;后，Spring 初始化容器时将会扫描 base-package指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为Spring Bean，业务层便可以通过Spring自动封装的特性来直接使用该对象。123456&lt;!-- 5. 配置 SpringData --&gt; &lt;!-- 加入 jpa 的命名空间 --&gt; &lt;!-- base-package: 扫描 Repository Bean 所在的 package --&gt; &lt;jpa:repositories base-package="com.syshlang" entity-manager-factory-ref="entityManagerFactory"&gt; &lt;/jpa:repositories&gt;声明持久层的接口&ensp;&ensp;&ensp;&ensp;声明持久层的接口，该接口继承Repository，Repository 是一个标记型接口，它不包含任何方法，如必要，Spring Data 可实现 Repository其他子接口，其中定义了一些常用的增删改查，以及分页相关的方法。持久层的接口:1234567891011121314/* * Copyright (c) 2018. GRGBanking * @File: PersonRepsotory.java * @Description: * @Author: sunys * @Date: 18-6-7 下午9:49 * @since: */package com.syshlang.repository;import com.syshlang.entity.Person;import org.springframework.data.repository.Repository;public interface PersonRepsotory extends Repository&lt;Person,Integer&gt;&#123;&#125;实体类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * Copyright (c) 2018. GRGBanking * @File: Person.java * @Description: * @Author: sunys * @Date: 18-6-7 下午9:54 * @since: */package com.syshlang.entity;import javax.persistence.*;import java.util.Date;@Table(name="JPA_PERSONS")@Entitypublic class Person &#123; private Integer id; private String lastName; private String email; private Date birth; @GeneratedValue @Id public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; @Override public String toString() &#123; return "Person [id=" + id + ", lastName=" + lastName + ", email=" + email + ", brith=" + birth + "]"; &#125;&#125;Repository 是一个空接口. 即是一个标记接口;若我们定义的接口继承了 Repository, 则该接口会被 IOC 容器识别为一个 Repository Bean.纳入到 IOC 容器中. 进而可以在该接口中定义满足一定规范的方法;实际上, 也可以通过 @RepositoryDefinition 注解来替代继承 Repository 接口。关于Repository接口相关概述参照《SpringData组件之Repository接口概述》。在接口中声明需要的方法&ensp;&ensp;&ensp;&ensp;在接口中声明需要的方法，Spring Data 将根据给定的策略来为其生成实现代码。123456789101112131415161718/* * Copyright (c) 2018. GRGBanking * @File: PersonRepsotory.java * @Description: * @Author: sunys * @Date: 18-6-7 下午9:49 * @since: */package com.syshlang.repository;import com.syshlang.entity.Person;import org.springframework.data.repository.Repository;public interface PersonRepsotory extends Repository&lt;Person,Integer&gt;&#123; //根据 lastName 来获取对应的 Person Person getByLastName(String lastName);&#125;测试：1234567 @Test public void testSpringData()&#123; PersonRepsotory personRepsotory = ctx.getBean(PersonRepsotory.class); Person person = personRepsotory.getByLastName("AA"); System.out.println(person);&#125;测试结果：1234567891011Hibernate: select person0_.id as id1, person0_.birth as birth2, person0_.email as email3, person0_.last_name as last_nam4 from jpa_persons person0_ where person0_.last_name=? Person [id=1, lastName=AA, email=syshlang@163.com, brith=2018-06-07 13:42:02.0]在 Repository 子接口中声明方法:不是随便声明的. 而需要符合一定的规范；查询方法以 find | read | get 开头；涉及条件查询时，条件的属性用条件关键字连接；要注意的是：条件属性以首字母大写；支持属性的级联查询. 若当前类有符合条件的属性, 则优先使用, 而不使用级联属性；若需要使用级联属性, 则属性之间使用 _ 进行连接。关于Repository子接口中声明方法参照《SpringData组件之Repository接口方法定义规范》。附：配置清单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.syshlang"&gt;&lt;/context:component-scan&gt; &lt;!-- 1. 配置数据源 --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;!-- 配置其他属性 --&gt; &lt;/bean&gt; &lt;!-- 2. 配置 JPA 的 EntityManagerFactory --&gt; &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--jpa是是实现产品的适配器--&gt; &lt;property name="jpaVendorAdapter"&gt; &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;!--扫描加注解的包--&gt; &lt;property name="packagesToScan" value="com.syshlang"&gt;&lt;/property&gt; &lt;property name="jpaProperties"&gt; &lt;props&gt; &lt;!-- 二级缓存相关 --&gt; &lt;!-- &lt;prop key="hibernate.cache.region.factory_class"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/prop&gt; &lt;prop key="net.sf.ehcache.configurationResourceName"&gt;ehcache-hibernate.xml&lt;/prop&gt; --&gt; &lt;!-- 生成的数据表的列的映射策略 --&gt; &lt;prop key="hibernate.ejb.naming_strategy"&gt;org.hibernate.cfg.ImprovedNamingStrategy&lt;/prop&gt; &lt;!-- hibernate 基本属性 --&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 3. 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt; &lt;property name="entityManagerFactory" ref="entityManagerFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4. 配置支持注解的事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 5. 配置 SpringData --&gt; &lt;!-- 加入 jpa 的命名空间 --&gt; &lt;!-- base-package: 扫描 Repository Bean 所在的 package --&gt; &lt;jpa:repositories base-package="com.syshlang" entity-manager-factory-ref="entityManagerFactory"&gt; &lt;/jpa:repositories&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringData</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用HttpServletRequestWrapper重写Request请求参数]]></title>
    <url>%2F79c4401c%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;在上一篇文章中讲述到，在做一个PHP语言开发的系统集成JAVA语言开发的系统功能时遇到获取传参的问题，最终是使用request.getInputStream()方式使问题得以解决，但是同时又带来了新的问题，request.getInputStream()本身获取到的是request请求内容的字节流，然后使用IOUtils.toString(IOUtils.toString)转为字符串，这种方式无法满足我的Controller层(springMVC)参数与实例对象的映射，增加了业务层处理参数的复杂度。问题分析&ensp;&ensp;&ensp;&ensp;既然request.getInputStream()获取参数无法满足Controller层需求，request.getParameter()方式可以满足但又无法获取参数，那何不先用request.getInputStream()获取到参数之后再重新设置request的参数以满足Controller层需求。但是，对于HttpServletRequest而言，貌似只有使用setAttribute(String name, Object o) 这个方法可以设置参数，经过尝试之后发现：使用 setAttribute(String name, Object o) 方法来重新设置参数不可行，因为在Controller中获取参数本质上还是调用的ServletRequest的public String getParameter(String name) 或者 public String[] getParameterValues(String name) 方法，了解一番之后，才明白需要使用装饰模式来复写这些方法才可行。因此，决定使用HttpServletRequestWrapper重写Request请求参数。代码实现&ensp;&ensp;&ensp;&ensp;Filter能在request到达servlet的服务方法之前拦截HttpServletRequest对象，而在服务方法转移控制后又能拦截HttpServletResponse对象，因此，可以使用filter来实现特定的任务————重写Request请求参数。使用HttpServletRequestWrapper重写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * Copyright (c) 2017 GRGBanking * @File: ChangeRequestWrapper.java * @Description: * @Author: sunys * @Date: 18-4-24 下午3:31 * @since: * */package com.grgbanking.framework.core.common;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.util.Enumeration;import java.util.Map;import java.util.Vector;/** * Created by sunys on 2018/4/24. */public class ChangeRequestWrapper extends HttpServletRequestWrapper &#123; private Map&lt;String, String[]&gt; parameterMap; // 所有参数的Map集合 public ChangeRequestWrapper(HttpServletRequest request) &#123; super(request); parameterMap = request.getParameterMap(); &#125; // 重写几个HttpServletRequestWrapper中的方法 /** * 获取所有参数名 * * @return 返回所有参数名 */ @Override public Enumeration&lt;String&gt; getParameterNames() &#123; Vector&lt;String&gt; vector = new Vector&lt;String&gt;(parameterMap.keySet()); return vector.elements(); &#125; /** * 获取指定参数名的值，如果有重复的参数名，则返回第一个的值 接收一般变量 ，如text类型 * * @param name 指定参数名 * @return 指定参数名的值 */ @Override public String getParameter(String name) &#123; String[] results = parameterMap.get(name); if (results != null)&#123; return results[0]; &#125; return null; &#125; /** * 获取指定参数名的所有值的数组，如：checkbox的所有数据 * 接收数组变量 ，如checkobx类型 */ @Override public String[] getParameterValues(String name) &#123; return parameterMap.get(name); &#125; @Override public Map&lt;String, String[]&gt; getParameterMap() &#123; return parameterMap; &#125; public void setParameterMap(Map&lt;String, String[]&gt; parameterMap) &#123; this.parameterMap = parameterMap; &#125;&#125;web.xml增加一个过滤器处理web.xml12345678910...&lt;filter&gt; &lt;filter-name&gt;securityAccessFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.grgbanking.framework.core.common.SecurityAccessFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;securityAccessFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;...&ensp;&ensp;&ensp;&ensp;所有的请求,都会验证此filter。新增Filter实现特定的任务SecurityAccessFilter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* * Copyright (c) 2017 GRGBanking * @File: SecurityAccessFilter.java * @Description: * @Author: sunys * @Date: 18-5-4 上午9:33 * @since: * */package com.grgbanking.framework.core.common;import com.grgbanking.framework.utils.AjaxUtils;import net.sf.json.JSONObject;import org.apache.commons.io.IOUtils;import org.apache.log4j.Logger;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;/** * 过滤器，在web.xml中配置，指定对哪些路径进行过滤。 */public class SecurityAccessFilter implements Filter &#123; private Logger logger = Logger.getLogger(SecurityAccessFilter.class); public void destroy() &#123; &#125; public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) arg0; HttpServletResponse response = (HttpServletResponse) arg1; String uri = request.getRequestURI(); if (uri.endsWith(".php"))&#123; //首先获取参数字符串 String json = new String(IOUtils.toString(request.getInputStream())); ServletRequest arg_tem = changeParam(json,request,response); if(arg_tem != null)&#123; //使用复写后的wrapper arg0 = arg_tem; &#125; &#125; arg2.doFilter(arg0, arg1); &#125; private ServletRequest changeParam(String json, HttpServletRequest request, HttpServletResponse response) &#123; try &#123; System.out.println(json); // 调用ChangeRequestWrapper 改变参数 ChangeRequestWrapper changeRequestWrapper = new ChangeRequestWrapper(request); Map&lt;String, String[]&gt; parameterMap = new HashMap&lt;&gt;(changeRequestWrapper.getParameterMap()); JSONObject jsonObject = JSONObject.fromObject(json); String param = jsonObject.get("param").toString(); parameterMap.put("param",new String[]&#123;param&#125;); changeRequestWrapper.setParameterMap(parameterMap); return changeRequestWrapper; &#125; catch (Exception e) &#123; e.printStackTrace(); AjaxUtils.renderFailureOther("解析请求参数时发生异常！", request,response); return null; &#125; &#125; public void init(FilterConfig arg0) throws ServletException &#123; &#125;&#125;]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Request</tag>
        <tag>HttpServletRequestWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP、JAVA关于post请求数据接收的处理]]></title>
    <url>%2F9a4c71ab%2F</url>
    <content type="text"><![CDATA[背景&ensp;&ensp;&ensp;&ensp;&ensp;最近在做项目时遇到这样一个问题，一个客户公司的智能柜管理系统想集成我们公司开发的电子锁系统，我负责相关接口的对接及开发，在一切准备工作就绪之后，进行接口联调时遇到传参问题的困扰。对方系统是采用PHP语言开发，我方系统是采用JAVA语言开发，接口约定采用post请求方式，以json格式传输数据，但是在实际接口联调中，PHP端使用curl请求JAVA接口时的传参JAVA端接口始终无法获取到，对方经过检查json数据格式没问题，但是我采用ajax请求JAVA端接口时可以获取到参数，于是推断是不同语言传输和接受参数的方式问题！分析JAVA接受post请求数据方式&ensp;&ensp;&ensp;&ensp;&ensp;&gt;Java的servlet中接收Post请求数据主要采用两种方式：(1) request.getParameter();(2) request.getInputStream();&ensp;&ensp;&ensp;&ensp;&ensp;Content-Type仅在取值为application/x-www-data-urlencoded和multipart/form-data两种情况下,request.getParameter()才能获取到值，否则返回空。Content-Type为其他类型时，一般采用request.getInputStream()方式获取，如下：12String json = org.apache.commons.io.IOUtils.toString(request.getInputStream()); System.out.println(json);&ensp;&ensp;&ensp;&ensp;&ensp;于是改用request.getInputStream()方式，问题得到解决，该方式返回request请求内容的字节流，转为字符串之后对取到的值进行处理,如果需要改变请求参数的值或者改变获取参数的方式满足Controller层的需求，可以通过使用HttpServletRequestWrapper重写Request请求参数来达到目的。request的Content-Type小结&ensp;&ensp;&ensp;&ensp;&ensp;application/x- www-form-urlencoded是Post请求默认的请求体内容类型，也是form表单默认的类型。Servlet API规范中对该类型的请求内容提供了request.getParameter()方法来获取请求参数值。但当请求内容不是该类型时，需要调用request.getInputStream()或request.getReader()方法来获取请求内容值。&ensp;&ensp;&ensp;&ensp;&ensp;当请求体内容（注意：get请求没有请求体）类型是application/x- www-form-urlencoded时也可以直接调用request.getInputStream()或request.getReader()方法获取到请求内容再解析出具体都参数，但前提是还没调用request.getParameter()方法。此时当request.getInputStream()或request.getReader()获取到请求内容后，无法再调request.getParameter()获取请求内容。即对该类型的请求，三个方法互斥，只能调其中一个。今天遇到一个Controller请求经过Spring MVC 的RequestMapping处理后，只能通过request.getParameter()获取到参数、无法通过request.getInputStream()和request.getReader()读取内容很可能就是因为在请求经过Spring MVC时已调用过request.getParameter()方法的原因。注意：在一个请求链中，请求对象被前面对象方法中调用request.getInputStream()或request.getReader()获取过内容后，后面的对象方法里再调用这两个方法也无法获取到客户端请求的内容，但是调用request.getParameter()方法获取过内容后，后面的对象方法里依然可以调用它获取到参数的内容。&ensp;&ensp;&ensp;&ensp;&ensp;当请求体内容是其它类型时，比如 multipart/form-data或application/json时，无法通过request.getParameter()获取到请求内容，此时只能通过request.getInputStream()和request.getReader()方法获取请求内容，此时调用request.getParameter()也不会影响第一次调用request.getInputStream()或request.getReader()获取到请求内容。request.getInputStream()返回请求内容字节流，多用于文件上传，request.getReader()是对前者返回内容的封装，可以让调用者更方便字符内容的处理（不用自己先获取字节流再做字符流的转换操作）。普及PHP知识PHP接收post请求数据方式&ensp;&ensp;&ensp;&ensp;&ensp;PHP接收post请求数据主要采用两种方式：(1) $_POST[index]方式(2) $data = file_get_contents(“php://input”);&ensp;&ensp;&ensp;&ensp;&ensp;Content-Type仅在取值为application/x-www-data-urlencoded和multipart/form-data两种情况下，PHP才会将http请求数据包中相应的数据填入全局变量$_POST。因此，如果使用$_POST来获取post过来的数据时，需要注意Content-Type类型，如果不是application/x-www-data-urlencoded和multipart/form-data，则采用file_get_contents(“php://input”);进行获取。&ensp;&ensp;&ensp;&ensp;&ensp; php://input 可以读取http entity body中指定长度的值,由Content-Length指定长度,不管是POST方式或者GET方法提交过来的数据。但是，一般GET方法提交数据 时，http request entity body部分都为空。例如在传递json串的时候，通过file_get_contents(“php://input”);获取原始串，然后通过json_decode()进行解析。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JAVA</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用问题总结及解决方案]]></title>
    <url>%2F1523b56c%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;&ensp; Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 [1] Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone，在本地机器上拷贝一个完整的Git仓库。不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。&ensp;&ensp;&ensp;&ensp;&ensp; 本篇文章专门用来记录本人在使用git过程中遇到的一些问题及解决方案，长期更新。FQA关键字：error: RPC failed问题&ensp;&ensp;&ensp;&ensp;&ensp;最近从Github上获取一份代码，在使用终端clone的时候，屡次出现如下错误：1234error: RPC failed; curl 18 transfer closed with outstanding read data remaining fatal: The remote end hung up unexpectedly fatal: early EOF fatal: index-pack failed原因说明我们的项目由于时代久远，所以导致整个项目比较复杂庞大。出现这种错误，就是因为curl的postBuffer默认值太小原因，重新在终端配置一下这个值就可以了。解决方法重新在终端配置postBuffer的值。12git config –global http.postBuffer 524288000 #524288000代表B，524288000B也就是500MB。这个值得大小，可以根据项目酌情设置。git config –list #查看是否配置成功关键字：回滚 恢复问题git reset –hard 回滚到之前的版本以后，怎么撤销这一步回滚操作？解决方法可以通过reflog来进行恢复，前提是丢失的分支或commit信息没有被git gc清除，一般情况下，gc对那些无用的object会保留很长时间后才清除的，可以使用git reflog show或git log -g命令来看到所有的操作日志，恢复的过程很简单：通过git log -g命令来找到需要恢复的信息对应的commitid，可以通过提交的时间和日期来辨别,找到执行reset –hard之前的那个commit对应的commitid；通过git branch recover_branch commitid 来建立一个新的分支。这样，就把到commitid为止的代码、各种提交记录等信息都恢复到了recover_branch分支上了。执行下面几个命令即可,详见git reset。123git reflog git checkoutgit branch关键字：命令Git最详细命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am "some comments"git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功git stash # 暂存git stash list # 列出所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支关键字： 分支 合并 主干问题如何使用git将分支branch合并到主干master上？解决方法假设现在有2个分支： master和 hexo-next1.使用如下命令从当前分支切换到主干master上1git checkout master2.合并某个分支到主干master1git merge &lt;branchName&gt;3.最重要的一步 push代码1git push origin]]></content>
      <categories>
        <category>technology</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>FQA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下配置网关]]></title>
    <url>%2F9d41370%2F</url>
    <content type="text"><![CDATA[讲解Linux系统下配置网关的基本操作，以CentOS 7 64位系统为例检查虚拟网卡这个硬件设备①：查看虚拟网卡这个硬件设备具体型号1[root@localhost]# lspci |grep Ethernet可以查看到该主机网卡为Intel 82545EM 千兆以太网卡②：查看目前网卡驱动程序版本信息12[root@localhost]# ethtool -i ethx[root@localhost]# ifconfig eth0提示：eth0: error fetching interface information: Device not found判断应该是没有安装网卡驱动安装网卡驱动①：前往Intel官网下载Intel 82545EM 千兆以太网卡驱动程序，http://www.intel.cn②：下载完成后，依次执行命令解压安装驱动包12[root@localhost]# tar zxf e1000-8.0.35.tar.gz[root@localhost]# cd e1000-8.0.35/src/ &amp;&amp; make install注：此驱动程序为源代码的程序包，安装前确认系统kernel-headers、kernel-firmware、kernel-devel三个软件包已经安装，且版本一定要相同，以及编译工具gcc、gcc-c++已经安装，如果没有安装，请配置正确的yum源后使用yum命令来安装配置网络①：查看路由表1[root@localhost]# route -n②：发现里面并没有我想要的网关，所以就要添加一个1[root@localhost]# route add 10.10.88.203 dev eth0③：重启network1[root@localhost]# service network restart]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>System</tag>
        <tag>network</tag>
        <tag>Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RFID射频识别技术预研]]></title>
    <url>%2F35059db1%2F</url>
    <content type="text"><![CDATA[预研背景&ensp;&ensp;&ensp;&ensp;公司预计将采用RFID技术来管理电动车。何谓RFID?&ensp;&ensp;&ensp;&ensp;无线射频识别技术（RFID，Radio Frequency Identification）是一种非接触的自动识别技术，其基本原理是利用射频信号和空间耦合（电感或者电磁耦合）传输特性，实现对被识别物体的自动识别。我们称无线射频识别技术也为电子标签系统。RFID系统组成&ensp;&ensp;&ensp;&ensp;RFID系统组成如下图&ensp;主要有三部分：天线(Antenna , or coil)读取器(Reader , transceiver)感应标签(Transponder, or RF Tag, 或硅芯片)&ensp;&ensp;&ensp;&ensp;RFID 读取流程如下图]]></content>
      <categories>
        <category>technology</category>
        <category>RFID</category>
      </categories>
      <tags>
        <tag>RFID</tag>
        <tag>电动车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用系统中的异常处理]]></title>
    <url>%2F1fe23ddd%2F</url>
    <content type="text"><![CDATA[背景某次安防项目的晨会上。质管小A：“安防项目今天突然不能播放视频了，点击播放按钮，提示失败，是不是底层C端出问题了！”底层C端研发负责人小B：“没有啊，怎么可能是我们C端的问题，昨天还是好好的，是不是业务系统出问题了！”业务系统负责人小C：“。。。。。。小明，小强你们两个排查下问题！”小明，小强经过一阵排查，发现播放视频的配置参数被修改了，没有填写端口号。分析&ensp;&ensp;&ensp;&ensp;从以上的事件中可以看出，问题的关键在于系统对于异常情况的处理不到位，并且对于出现问题的提示信息过于片面化，导致问题出现时，无法迅速定位问题所在。我们开发的业务系统,或者是产品,常常面临着这样的问题:系统运行出错,但是完全不知道错误发生的位置；我们找到了错误的位置,但是完全不知道是因为什么；系统明明出了错误,但是就是看不到错误堆栈信息。&ensp;&ensp;&ensp;&ensp;由此，J2EE Web应用系统中的异常处理显得尤为重要，优雅的以正确的方式处理异常，不仅可以提高系统健壮性的，并且还可以有效的帮助我们速度的定位排查问题。异常的分类从异常的分类结构看&ensp;&ensp;&ensp;&ensp;由异常的分类结构图可以看出：Throwable类有两个直接子类java.lang.Error和java.lang.Exception，Error是无法处理的异常，一般发生这种异常，JVM会选择终止程序，编写程序时不需要关心；Exception是常见异常情况，这些异常是我们可以处理的异常，是所有异常类的父类。从异常的受检查情况来看&ensp;&ensp;&ensp;&ensp;从异常的受检查情况来看,可捕获的异常又可以分为两类：check异常（受查异常(checked exception)）和runtime异常（非受查异常(unchecked exception)）。对于非受查异常，派生自RuntimeException的异常类，对于此类异常java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定；对于受查异常，直接派生自Exception的异常类，java编译器强制程序员必须进行捕获处理，否则编译都不通过。从系统的应用角度来看(1) 系统级异常————与应用业务逻辑无关，需要有JVM系统来处理的异常；(2) 应用级异常————由于用户违背了商业业务逻辑而导致的错误，这种错误一般不是致命的，需要由应用系统程序本身处理。Web应用中的异常处理机制和实现技术异常的处理机制Web应用中的异常处理(1) 不要让用户看到原始的Java异常信息，也是就说禁止将异常的堆栈信息抛出到页面上；(2) 可以将原始的Java异常信息记录到日志文件中或者输出到控制台，这样有助于程序调试中的错误定位；(3) 在分层系统实现中的异常处理规则：&ensp;&ensp;&ensp;&ensp;① 在分层系统实现中，下层系统向上层系统报告异常错误时，通常采用抛出自定义异常的方式实现，这样以便统一系统中不同的异常类型，例如，在项目中定义一个 AppException,然后向上层系统抛出这个异常：12345public class AppException extends RuntimeException&#123; public AppException(String message)&#123; super(message); &#125;&#125;&ensp;&ensp;&ensp;&ensp;② 设计自定义异常时，一般让自定义异常直接继承RuntimeException(非受查异常),从而使得上层的系统代码不必进行与异常相关的处理，这样也就使得上层程序代码不必依赖于下层的程序代码实现,这在一定程度上降低了代码的耦合度；&ensp;&ensp;&ensp;&ensp;③ 在控制层组件中捕获用户自定义的异常，在表示层组件中处理未捕获的异常，例如，定义错误页面等；&ensp;&ensp;&ensp;&ensp;④ 根据不同的业务场景或层级定义不同的异常类，例如，我们定义ServiceException异常类,用来表示业务逻辑受理失败,它仅表示我们处理业务的时候发现无法继续执行下去；12345public class ServiceException extends AppException&#123; public ServiceException(String message)&#123; super(message); &#125;&#125;(4)利用框架的相关机制处理异常，例如，spring为我们提供了ControllerAdvice机制,进行全局的 Controller 层异常处理：1234567891011121314/*** @ControllerAdvice + @ExceptionHandler 进行全局的 Controller 层异常处理，* 不用在 Controller 层进行 try-catch * */@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(&#123; ServiceException.class &#125;) @ResponseBody public AppResponse handleException(Exception e) &#123; &#125; &#125;(5) 异常设计的初衷是解决程序运行中的各种意外情况,且异常的处理效率比条件判断方式要低很多，如果考虑效率的话，可以重写Throwable的fillStackTrace方法，fillStackTrace是一个native方法,会填充异常类内部的运行轨迹；(6) 不要用异常进行业务逻辑处理，我们提倡在业务处理的时候,如果发现无法处理直接抛出异常即可。]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Exception</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统架构演进]]></title>
    <url>%2Ff502a05%2F</url>
    <content type="text"><![CDATA[系统架构演进首先，给个图。。。&ensp;&ensp;&ensp;&ensp;从以上的演进图中，我们可以很清晰的看出:平台随着业务的发展从 All in One 环境就可以满足业务需求（以Java来说，可能只是一两个war包就解决了）；发展到需要拆分多个应用，并且采用MVC的方式分离前后端，加快开发效率；在发展到服务越来越多，不得不将一些核心或共用的服务拆分出来，提供实时流动监控计算等，其实发展到此阶段，如果服务拆分的足够精细，并且独立运行，这个时候至少可以理解为SOA架构了。特点概述：单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC) 是关键。分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Dubbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC和mybatis的整合]]></title>
    <url>%2F820c489b%2F</url>
    <content type="text"><![CDATA[SpringMVC+mybaits的系统架构SpringMVC+mybaits整合步骤第一步：整合dao层&ensp;&ensp;&ensp;&ensp;&ensp;在doDispatch()方法中调用了DispatcherServlet类的getHandler方法。映射器根据request当中的URL，找到了Handler，最终返回一个执行器的链(HandlerExecutionChain)。这个链里面有Handler。配置mybatis的全局配置文件：sqlMapConfig.xmlsqlMapConfig.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!--mybatis的全局配置文件--&gt;&lt;!-- 全局setting配置，根据需要添加 --&gt;&lt;!-- 配置别名 --&gt;&lt;typeAliases&gt; &lt;!-- 批量扫描别名 --&gt; &lt;package name="com.syshlang.smm.pojo"/&gt;&lt;/typeAliases&gt;&lt;!-- 配置mapper由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。必须遵循：mapper.xml和mapper.java文件同名且在一个目录 --&gt;&lt;!--&lt;mappers&gt; 通过mapper元素的resource属性可以指定一个相对于类路径的Mapper.xml文件 &lt;mapper resource="com/syshlang/smm/mapping/ItemsMapper.xml"/&gt; 通过mapper元素的url属性可以指定一个通过URL请求道的Mapper.xml文件 &lt;mapper url="file:///E:\Workspaces\Intellij\SpringMM\src\main\resources\com\syshlang\smm\mapping\ItemsMapper.xml"/&gt; 通过mapper元素的class属性可以指定一个Mapper接口进行注册 &lt;mapper class="com.syshlang.smm.mapper.ItemsMapper"/&gt; 通过package元素将会把指定包下面的所有Mapper接口进行注册 &lt;package name="com.syshlang.smm.mapper"/&gt;&lt;/mappers&gt;--&gt;&lt;/configuration&gt;配置spring和mybatis整合的配置文件：applicationContext-dao.xml主要包括数据源、SqlSessionFactory、mapper扫描器等applicationContext-dao.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 加载db.properties文件中的内容，db.properties文件中key命名要有一定的特殊规则 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置数据源 ，dbcp --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="30" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:config/mybatis/sqlMapConfig.xml" /&gt; &lt;property name="mapperLocations" value="classpath:com/syshlang/smm/mapping/*Mapper.xml"/&gt; &lt;!--分页插件--&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageHelper"&gt; &lt;property name="properties"&gt; &lt;value&gt; dialect=mysql reasonable=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 --&gt; &lt;property name="basePackage" value="com.syshlang.smm.mapper"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt;&lt;/beans&gt;第二步：整合service层&ensp;&ensp;&ensp;&ensp;&ensp;通过spring管理 service接口,使用配置方式将service接口配置在spring配置文件中,实现事务控制。配置service：applicationContext-service.xmlapplicationContext-service.xml12345678910111213141516&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;bean id="itemsserviceimpl" class="com.syshlang.smm.service.impl.ItemsServiceImpl" /&gt;&lt;/beans&gt;使用spring声明事务控制方法，配置事务控制：applicationContext-transaction.xmlapplicationContext-transaction.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 dataSource在applicationContext-dao.xml中配置了 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.syshlang.smm.service.impl.*.*(..))"/&gt; &lt;/aop:config&gt; &lt;!-- &lt;aop:config&gt; &lt;aop:pointcut id="transactionPointcut" expression="execution(* com.syshlang.smm.service.impl.*.*Dao.*(..))" /&gt; &lt;aop:advisor pointcut-ref="transactionPointcut" advice-ref="txAdvice" /&gt; &lt;/aop:config&gt;--&gt;&lt;/beans&gt;第三步：整合SpringMVC&ensp;&ensp;&ensp;&ensp;&ensp;由于SpringMVC是spring的模块，不需要整合，只需配置spring-mvc.xml文件，包括处理器映射器、适配器、视图解析器等。配置:spring-mvc.xmlspring-mvc.xml12345678910111213141516171819202122232425262728293031323334353637&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 自动扫描包，实现支持注解的IOC --&gt; &lt;context:component-scan base-package="com.syshlang.smm" /&gt; &lt;!-- Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--注解映射器 支持mvc注解驱动--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 扫描指定controller的包--&gt; &lt;!--&lt;context:component-scan base-package="com.syshlang.smm.controller"&gt;&lt;/context:component-scan&gt;--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; 配置jsp路径的后缀 &lt;property name="suffix" value=".jsp" /&gt; --&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc配置详解及源码分析]]></title>
    <url>%2F375e3f9d%2F</url>
    <content type="text"><![CDATA[SpringMVC配置详解配置前端控制器DispatcherServlet&ensp;&ensp;&ensp;&ensp;&ensp;SpringMVC是一个基于DispatcherServlet的MVC框架，每一个请求最先访问的都是DispatcherServlet，DispatcherServlet是继承自HttpServlet的，DispatcherServlet负责转发每一个Request请求给相应的Handler，Handler处理以后再返回相应的视图(View)和模型(Model)，返回的视图和模型都可以不指定，即可以只返回Model或只返回View或都不返回。&ensp;&ensp;&ensp;&ensp;&ensp;首先，在web.xml文件中声明DispatcherServlet：web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; /WEB-INF/applicationContext.xml, classpath:springmvc.xml, &lt;/param-value&gt; &lt;/context-param&gt;--&gt; &lt;!--&lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;log4j.properties&lt;/param-value&gt; &lt;/context-param&gt;--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--SpringMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation 配置SpringMVC加载的配置文件（配置处理器映射器、适配器等） 如果不配置，默认加载的是/WEB_INF/servlet名称-servlet.xml(dispatcher-servlet.xml) --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 1)load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其 init()方法)。 2)它的值必须是一个整数，表示servlet应该被载入的顺序 2)当值为0或者大于0时，表示容器在应用启动时就加载并初始化这个servlet； 3)当值小于0或者没有指定时，则表示容器在该servlet被选择时才会去加载。 4)正数的值越小，该servlet的优先级越高，应用启动时就越先加载 5)当值相同时，容器就会自己选择顺序来加载。 所以，&lt;load-on-startup&gt;x&lt;/load-on-startup&gt;， 中x的取值1，2，3，4，5代表的是优先级，而非启动延迟时间。 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!-- &lt;async-supported&gt;子标签，该标签的默认取值为false， 要启用异步处理支持，则将其设为true即可 --&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;!-- ① *.action，访问以.action结尾的由DispatcherServlet进行解析； ② /,所有/的地址都由DispatcherServlet进行解析， 对于静态的文件的解析需要配置不让DispatcherServlet进行解析， 使用此种风格可以实现RESTFull风格的url解析； ③ /*，这样配置错误，使用这种配置时，最终要转发到jsp页面时， 仍然会由DsipatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--welcome pages--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;配置处理器适配器、映射器、视图解析器等&ensp;&ensp;&ensp;&ensp;&ensp;然后，在classpath下的spring-mvc.xml中配置处理器适配器：spring-mvc.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 说明：前端控制器加载处理映射器、适配器、视图解析器等组件，如果不在spring-mvc.xml中配置，则会自动使用spring-webmvc-4.3.1.RELEASE.jar包中org\springframework.web.servlet中DispatcherSerlvet.properties配置文件中的默认配置。 --&gt; &lt;!--启用spring的一些annotation --&gt; &lt;!--&lt;context:annotation-config/&gt;--&gt; &lt;!-- ****************配置Handler 开始*********************--&gt; &lt;bean id="queryController" name="/query.action" class="com.syshlang.smm.controller.QueryController"&gt;&lt;/bean&gt; &lt;bean id="queryHttpController" name="/httpquery.action" class="com.syshlang.smm.controller.QueryHttpController"&gt; &lt;/bean&gt; &lt;!-- 对于注解的Handler可以单个配置,实际开发中建议使用组件扫描 可以扫描controller、service、...这里让扫描controller，指定controller的包 --&gt; &lt;!--&lt;bean class="com.syshlang.smm.controller.QueryAnnotationController" /&gt;--&gt; &lt;context:component-scan base-package="com.syshlang.smm.controller"&gt; &lt;/context:component-scan&gt; &lt;!-- ****************配置Handler 结束*********************--&gt; &lt;!-- *********************配置处理器映射器 开始*************************************** --&gt; &lt;!-- 所有的适配器都实现了HandlerMapping接口 --&gt; &lt;!--第一种方式：最简单的，一个class对应一个handler（非注解） 将bean的name当作url来查找，需要在配置Handler时配置bean的name(就是url)，如上 --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt; &lt;/bean&gt; &lt;!--第二种方式 集中映射配置 （非注解） SimpleUrlHandlerMapping是BeanNameUrlHandlerMapping的增强版本， 它可以将url和处理器的bean的id进行统一的映射配置 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/query0.action"&gt;queryController&lt;/prop&gt; &lt;prop key="/query1.action"&gt;queryController&lt;/prop&gt; &lt;prop key="/httpquery0.action"&gt;queryHttpController&lt;/prop&gt; &lt;prop key="/httpquery1.action"&gt;queryHttpController&lt;/prop&gt; &lt;!--&lt;prop key="url地址"&gt;Controller的bean的id&lt;/prop&gt;--&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 第三种方式 注解映射器 在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping注解映射器。在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 结论：① 多个映射器可以并存； ② 一个bean可以对应多个url； ③HandlerMapping 无需配置，springmvc可以默认启动； ④使用注解的映射器和注解的适配器。（注解的映射器和注解的适配器必须配对使用）。 --&gt; &lt;!-- ********************************配置处理器映射器 结束************************** --&gt; &lt;!-- *********************配置处理器适配器 开始*************************************** --&gt; &lt;!-- 所有的处理器适配器都实现HandlerAdapter接口 --&gt; &lt;!--①配置处理器适配器 (非注解) public boolean supports(Object handler) &#123; return handler instanceof Controller; &#125; SimpleControllerHandlerAdapter中的support方法可以看出： 编写的handler需要实现Controller接口 public interface Controller &#123; ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception; &#125; 由此，开发Handler时需要实现Controller接口才能由org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter来执行 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt; &lt;/bean&gt; &lt;!-- ②HttpRequestHandlerAdapter 是http请求处理适配器， (非注解) 所有实现了HttpRequestHandler接口的bean通过此适配器进行适配、执行 public boolean supports(Object handler) &#123; return handler instanceof HttpRequestHandler; &#125; 由HttpRequestHandlerAdapter中的support方法可以看出： 编写的handler需要实现HttpRequestHandler接口 public interface HttpRequestHandler &#123; void handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws ServletException, IOException;&#125; --&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt; &lt;!--③注解适配器 在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter注解适配器。在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器。 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- *********************配置处理器适配器 结束*************************************** --&gt; &lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;!-- &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; --&gt; &lt;!-- *********************配置视图解析器 开始*************************************** --&gt; &lt;!--视图解析器 解析jsp文件，默认使用jstl的标签 classpatch下要有jstl的jar包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;/bean&gt; &lt;!-- *********************配置视图解析器 结束*************************************** --&gt; &lt;bean id="log4jInitialization" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt; &lt;property name="targetClass" value="org.springframework.util.Log4jConfigurer" /&gt; &lt;property name="targetMethod" value="initLogging" /&gt; &lt;property name="arguments"&gt; &lt;list&gt; &lt;value&gt;classpath:log4j.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;开发Handler&ensp;&ensp;&ensp;&ensp;&ensp;在此处只举一例，如下：&ensp;&ensp;&ensp;&ensp;&ensp;通过实现 controller接口，由org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter适配器执行的情况。123456789101112131415161718192021222324252627282930313233343536373839404142package com.syshlang.smm.controller;import com.syshlang.smm.pojo.QueryPojo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.ArrayList;import java.util.List;/** * Created by sunys on 2017/7/1 2:44. * Description: 使用SimpleControllerHandlerAdapter处理器适配器实现Controller接口的处理器 */public class QueryController implements Controller&#123; //添加一个日志器 private static final Logger logger = LoggerFactory.getLogger(QueryController.class); @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //调用service层，查询数据库 List&lt;QueryPojo&gt; list = new ArrayList&lt;QueryPojo&gt;(); QueryPojo pojo = new QueryPojo(); pojo.setId("1"); pojo.setName("aaaaaa"); list.add(pojo); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribut,在jsp页面通过list取值 modelAndView.addObject("listpojo",list); modelAndView.addObject("des","使用SimpleControllerHandlerAdapter处理器适配器实现Controller接口的处理器"); //指定视图View modelAndView.setViewName("/view/query.jsp"); //输出日志文件 logger.info("the first jsp pages"); return modelAndView; &#125;&#125;源码分析源码分析&ensp;&ensp;&ensp;&ensp;&ensp;根据配置过程，通过前端控制器源码分析SpringMVC的执行过程。第一步：前端控制器接收请求&ensp;&ensp;&ensp;&ensp;&ensp;在org.springframework.web.servlet.DispatcherServlet中可以看到doDispatch方法。前端控制器接收请求，.action类型的URL通过过滤器进入DispatcherServlet类，doDispatch()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; try &#123; ModelAndView mv = null; Object dispatchException = null; try &#123; processedRequest = this.checkMultipart(request); multipartRequestParsed = processedRequest != request; mappedHandler = this.getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; this.noHandlerFound(processedRequest, response); return; &#125; HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); String method = request.getMethod(); boolean isGet = "GET".equals(method); if (isGet || "HEAD".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified); &#125; if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; this.applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception var20) &#123; dispatchException = var20; &#125; catch (Throwable var21) &#123; dispatchException = new NestedServletException("Handler dispatch failed", var21); &#125; this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); &#125; catch (Exception var22) &#123; this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22); &#125; catch (Throwable var23) &#123; this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23)); &#125; &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else if (multipartRequestParsed) &#123; this.cleanupMultipart(processedRequest); &#125; &#125; &#125;第二步：前端控制器调用处理器映射器查找 Handler&ensp;&ensp;&ensp;&ensp;&ensp;在doDispatch()方法中调用了DispatcherServlet类的getHandler方法。映射器根据request当中的URL，找到了Handler，最终返回一个执行器的链(HandlerExecutionChain)。这个链里面有Handler。12345678910111213141516171819protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; Iterator var2 = this.handlerMappings.iterator(); HandlerExecutionChain handler; do &#123; if (!var2.hasNext()) &#123; return null; &#125; HandlerMapping hm = (HandlerMapping)var2.next(); if (this.logger.isTraceEnabled()) &#123; this.logger.trace("Testing handler map [" + hm + "] in DispatcherServlet with name '" + this.getServletName() + "'"); &#125; handler = hm.getHandler(request); &#125; while(handler == null); return handler; &#125;第三步：调用处理器适配器执行Handler，得到执行结果ModelAndView123...mv = ha.handle(processedRequest, response, mappedHandler.getHandler());...第四步：视图渲染，将model数据填充到request域。&ensp;&ensp;&ensp;&ensp;&ensp;视图解析，得到view:在doDispatch()方法中1this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);1234567891011121314151617181920212223242526272829private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; this.logger.debug("ModelAndViewDefiningException encountered", exception); mv = ((ModelAndViewDefiningException)exception).getModelAndView(); &#125; else &#123; Object handler = mappedHandler != null ? mappedHandler.getHandler() : null; mv = this.processHandlerException(request, response, handler, exception); errorView = mv != null; &#125; &#125; if (mv != null &amp;&amp; !mv.wasCleared()) &#123; this.render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Null ModelAndView returned to DispatcherServlet with name '" + this.getServletName() + "': assuming HandlerAdapter completed request handling"); &#125; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; if (mappedHandler != null) &#123; mappedHandler.triggerAfterCompletion(request, response, (Exception)null); &#125; &#125; &#125;在processDispatchResulth()方法中1this.render(mv, request, response);12345678910111213141516171819202122232425262728293031323334protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; Locale locale = this.localeResolver.resolveLocale(request); response.setLocale(locale); View view; if (mv.isReference()) &#123; view = this.resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException("Could not resolve view with name '" + mv.getViewName() + "' in servlet with name '" + this.getServletName() + "'"); &#125; &#125; else &#123; view = mv.getView(); if (view == null) &#123; throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a " + "View object in servlet with name '" + this.getServletName() + "'"); &#125; &#125; if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Rendering view [" + view + "] in DispatcherServlet with name '" + this.getServletName() + "'"); &#125; try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; view.render(mv.getModelInternal(), request, response); &#125; catch (Exception var7) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Error rendering view [" + view + "] in DispatcherServlet with name '" + this.getServletName() + "'", var7); &#125; throw var7; &#125; &#125;在render()方法中1view = this.resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);调用view的渲染方法，将model数据填充到request域1view.render(mv.getModelInternal(), request, response);根据InternalResourceView的继承关系：org.springframework.web.servlet.view.AbstractView ,org.springframework.web.servlet.view.AbstractUrlBasedView,org.springframework.web.servlet.view.InternalResourceView 最终找到render方法在AbstractView中，如下代码所示：123456789public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace("Rendering view with name '" + this.beanName + "' with model " + model + " and static attributes " + this.staticAttributes); &#125; Map&lt;String, Object&gt; mergedModel = this.createMergedOutputModel(model, request, response); this.prepareResponse(request, response); this.renderMergedOutputModel(mergedModel, this.getRequestToExpose(request), response); &#125;123456789101112131415161718192021protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123; Iterator var3 = model.entrySet().iterator(); while(var3.hasNext()) &#123; Entry&lt;String, Object&gt; entry = (Entry)var3.next(); String modelName = (String)entry.getKey(); Object modelValue = entry.getValue(); if (modelValue != null) &#123; request.setAttribute(modelName, modelValue); if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Added model object '" + modelName + "' of type [" + modelValue.getClass().getName() + "] to request in view with name '" + this.getBeanName() + "'"); &#125; &#125; else &#123; request.removeAttribute(modelName); if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Removed model object '" + modelName + "' from request in view with name '" + this.getBeanName() + "'"); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架组件学习之SpringMVC]]></title>
    <url>%2F3b06d7c3%2F</url>
    <content type="text"><![CDATA[SpringMVC框架SpringMVC框架是什么 &ensp;&ensp;&ensp;&ensp;从以上的框架图中，我们可以很清晰的看出:Springmvc是一个基于mvc的web框架，并且它是spring框架的一个模块。由此，我们在开发的过程中，SpringMVC和spring无需通过中间整合层进行整合。mvc在b/s系统下的应用&ensp;&ensp;&ensp;&ensp;&ensp;mvc是一个设计模式，mvc在b/s系统下的应用,如下图：SpringMVC框架&ensp;&ensp;&ensp;&ensp;&ensp;SpringMVC框架，用户发出一个请求时，处理流程如下图：&ensp;&ensp;&ensp;&ensp;&ensp;根据以上处理流程图，总结如下：发起请求到前端控制器(DispatcherServlet)；前端控制器请求HandlerMapping查找Handler可以根据xml配置、注解进行查找(DispatcherServlet)；处理器映射器HandlerMapping向前端控制器返回Handler；前端控制器调用处理器适配器去执行Handler；处理器适配器去执行Handler；Handler执行完成给适配器返回ModelAndView；处理器适配器向前端控制器返回ModelAndView,ModelAndView是SpringMVC框架的一个底层对象，包括Model和view；前端控制器请求视图解析器去进行视图解析根据逻辑视图名解析成真正的视图(jsp)；视图解析器向前端控制器返回View；前端控制器进行视图渲染视图渲染将模型数据(在ModelAndView对象中)填充到request域；前端控制器向用户响应结果。&ensp;&ensp;&ensp;&ensp;&ensp;在这个流程中所涉及到组件：前端控制器DispatcherServlet（不需要程序员开发）作用：接收请求，响应结果，相当于转发器，中央处理器，有了DispatcherServlet减少了其它组件之间的耦合度。处理器映射器HandlerMapping(不需要程序员开发)作用：根据请求的url查找Handler处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler处理器Handler(需要程序员开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler视图解析器View resolver(不需要程序员开发)作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）视图View(需要程序员开发jsp)View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）]]></content>
      <categories>
        <category>technology</category>
        <category>JAVA</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2Ff77810a8%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX19nF12RT9zyHZRi3TGs/uA4N+Gfx6t/Gtyl7bYHnnQ+CAEpw/Z/unoW933v4DElyGqnkAYVG5r5dtNq0vYZHuQmomlZgj/Ov+ZYy9p2jZTHcB76K7Qk0Y6oZCHc4BoaVZyF+AYCBdI5HnukuVR5n3Iy+gjYmjW0WIEJgRIpbQBRcuc+GpyBx0m/jc2dHA22My88V0oF5icPM1XVRnq9LIzew6jPwopoHNI/s8eET/WZm8tc5YhuS7sTcWnohkFubBWnii0t0Q+HPpcL7m/3GcBOuvoy0GJ/fYUqXaAvf6Cx/JMFQbpxRAnG+J2nJY3gFtR5u6K3aipFeDXBK/re4C0ZK/KRMI5ZhCZHD7RUa92ZDGooSrevm3MtTaw5RS2P/eCH7tWMUZTaQthnoj9khr2lyegeY6eMRd+93hX5S2IcSEAb9Pfd8+l5DD/RqAyK/sLsN8OW3KU3hiMhAz9x25XI8cu2Lmu/i5A43KWmBac4jH9y6BAoPaBJmVXeEkPW/jwayyMbwe5cMt4yCXHeYGC5/rCyljQgvS7uCC6hYS7BDe73cNdpOLGVnMOCCpEwVxGVKk+C7cxXs5AvxTntzP6P+FdmFLxXiS00cD3TFqAisXpO+HiZoiu3CDnc2FoIg4s+Xm0etmxRS9nqh57YHFPsK7XdjK8yweHOchuj/xxk9HL9gQDn7cKQ8rSDBK1KyX/m176uK9KJtYnmoL4Y2Q9g8tGPKO7q1eetJlic9ACze7qQkR1rEyv8qGLy/hVcENL1N7AkxkXlzs5pi7BB1m0uwLynzl4lkllwCoAG002jXUvTm4eiMHn8Go0bsV32i7AFKLG/rqGx3e5H6GW1zoi1eU1DcuhpKLietolPzK51sjyvwNSQnnBOKTVOA/9I5/0QXUXxP60mzO/xAtRjmGsk1U1BHTR8bnJzd4pgTPGbw39eiCVMGSl4YACfx21mrSwzTHC+Mgrz7CaeNaRYqNNfoRHWJgiDp702OT8XCKzsIwceuWD65Gt1prizdP/pmGFvl1LAkjuNkKWm3pP7f0p97MPNtgivxh/Px0sEcdDVa9N2v3CFXRXw2UuzC+NLeOtizESHO2iwaRbsh8ajD6eeeK4jS3duAVGykHJ6bfW7gbx2ZexBXX39AZ7+2sxtLADqAtwg6FReXXeFCSLelvQ69bMwxWwKN6GbBxCLIUgPrn2EQI8NsULvJpZMoGt5qXb5uWLZLeQ7ogHXol6GOsn0T46eaSyDY2ujULaJFK2yAioo8XMsAT1w2KcXP4HnrIFgiCfE0Wcpn1VqM5R5QZYpS4dBSq52hXHt1zqRyWdw459pmywSNvVRx8/6ZoWgYgLWPY4/ROoqswad6b6f0GqocGOyIGLzEbqre3KKc9O5HiBk2u8iGK9wUpSy9dlaCqxAUBfzwCdwyi3vlN64aOnIIiYglZnwbFNTrU3HTyijGc3IpwPGa097Osrn5vz7IxSxOo3yz71xQwCz1zQKy+lg2GIAqzxLAwB1zE1S2ohePI7f2PN7NHc3UV5UOlLOSz53QaX1a4W/iFnFVFMifkiKnBh0aSiFR3mMlS9YGQRrcsbImismz534xSnGCmacEH/hJkBIk13YJfZRGOs5zcYz8mONQsu6MjcMuhTN5tGPx76Fu5bqeVGQnnAjkwSKqYG3DaeSTE+YxA9GJlWBQNuiMz8KE6GW8k14e1JKR495yQJJd53qIl6sJHOBG9UiYxkWgugV7Xdm+oON2tERGIJj1AfuWLcWXimJaJgIzfEU89ofR9y6NQ2uB77SBDN3gUbRWrNeGNFUptJxYiF1ej48UyGUPzD8mRENi27NFdH/2Hfevw3Z7FIkpalZpTVjtjI7lJ3fDM7MRpkvkVq1Md/uO8k9AZV2WgaJkcSDtdTFai5igsbKkuZl0ujUFVDaFyMaTygUA/uioAkGUqpeMNZqUPPm0vN/mdrp/+18D9cSrlbgDn0ljQUoj52ZD672tgVlPhNx5gmVWBRVLRscxVLDZXbaeTf+mzQIG2K9MJDJtS/lvt/g0XGP7mC82AWZ9noH0ZwLMQPYWnC1kzen05T5s8C9MO6U9V6qh+1Zn0qy61Se27mPwn9ZyQfbBex5m3HcueI4r1Xoml1qA105AGQAr9UYjIPZd21uEVl6xBlGkijcnmw9mefQWObUQ2kBYROXrDn+V3d8AnJF8nlj1OdcnpGNdjPZi/vnmo6QyuQWak0eJ7HWwC2KcM0g3P3+021EDmm4LFC+7yC5acuWCoIbfujV9/qK+v5WQlOsoWeP7bRb3WFy0r3Py2olrLnBgJbaXqnK1AdleQ==]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下操作集锦]]></title>
    <url>%2Fb529e05a%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;&ensp; 本篇文章专门用来记录本人在使用Linux系统过程一些操作技巧和遇到的一些问题及解决方案，长期更新。SOLUTIONLinux系统下配置网关详见《Linux系统下配置网关》。Linux系统下关闭/开启防火墙Centos 7 firewall 命令查看已经开放的端口1[root@sunys ~]# firewall-cmd --list-ports开启端口1[root@sunys ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent– zone #作用域– add-port=80/tcp #添加端口，格式为：端口/通讯协议– permanent #永久生效，没有此参数重启后失效重启/停止/停止/查看防火墙1234[root@sunys ~]# firewall-cmd --reload #重启firewall[root@sunys ~]# systemctl stop firewalld.service #停止firewall[root@sunys ~]# systemctl disable firewalld.service #禁止firewall开机启动[root@sunys ~]# firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）CentOS 7 以下版本 iptables 命令查看防火墙状态12[root@sunys ~]# service iptables statusiptables: Firewall is not running.查看打开的端口1[root@sunys ~]# /etc/init.d/iptables status开启端口①使用命令行：12[root@sunys ~]# /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT[root@sunys ~]# /etc/rc.d/init.d/iptables save #保存②或者修改/etc/sysconfig/iptables 文件，添加以下内容：12-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT重启/停止/停止/查看防火墙①永久关闭，重启后生效开启： chkconfig iptables on关闭： chkconfig iptables off②即时生效，重启后失效开启： service iptables start关闭： service iptables stop查看 SELinux状态 &amp; 关闭 SELinux查看SELinux状态① getenforce 命令是单词get（获取）和enforce(执行)连写，可查看selinux状态，与setenforce命令相反。12[root@sunys ~]# getenforceEnforcing② /usr/sbin/sestatus 查看详细参数12345678910[root@sunys ~]# /usr/sbin/sestatusSELinux status: enabledSELinuxfs mount: /sys/fs/selinuxSELinux root directory: /etc/selinuxLoaded policy name: targetedCurrent mode: enforcingMode from config file: enforcingPolicy MLS status: enabledPolicy deny_unknown status: allowedMax kernel policy version: 28SELinux status：selinux防火墙的状态，enabled表示启用selinux防火墙Current mode： selinux防火墙当前的安全策略，enforcing 表示强关闭SELinux①临时关闭setenforce 命令则是单词set（设置）和enforce(执行)连写，用于设置selinux防火墙状态，如： setenforce 0用于关闭selinux防火墙，但重启后失效1234567891011[root@sunys ~]# setenforce 0[root@sunys ~]# /usr/sbin/sestatusSELinux status: enabledSELinuxfs mount: /sys/fs/selinuxSELinux root directory: /etc/selinuxLoaded policy name: targetedCurrent mode: permissiveMode from config file: enforcingPolicy MLS status: enabledPolicy deny_unknown status: allowedMax kernel policy version: 28②永久关闭修改selinux的配置文件，重启后生效。打开 selinux 配置文件,将SELINUX=enforcing改为SELINUX=disabled。123456789101112[root@sunys ~]# vim /etc/selinux/config# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=enforcing# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection.SELINUXTYPE=targeted重启1[root@sunys ~]# reboot验证1234[root@sunys ~]# /usr/sbin/sestatusSELinux status: disabled[root@sunys ~]# getenforceDisabledCentOS下开启SSH Server服务查看SSH是否安装1[root@sunys ~]# rpm -qa | grep ssh若没安装SSH则可输入一下命令安装1[root@sunys ~]# yum install openssh-server启动SSH服务1[root@sunys ~]# systemctl start sshd重启SSH服务1[root@sunys ~]# systemctl restart sshd停止SSH服务1[root@sunys ~]# systemctl stop sshd启动后可输入一下命令查看是否启动22端口（可略）1[root@sunys ~]# netstat -antp | grep sshd设置SSH服务为开机启动1[root@sunys ~]# systemctl enable sshd设置禁止SSH开机启动1[root@sunys ~]# systemctl disable sshdlinux下java读取串口相关问题权限相关问题 No permission to create lock fileissue:CentOS下部署短信猫时报错：check_group_uucp(): error testing lock file creation Error details:权限不够check_lock_status: No permission to create lock file.please see: How can I use Lock Files with rxtx? in INSTALLcause:这个问题源于试图在/ var / lock中创建锁文件的rxtx包。 可以通过更改访问权限（以root身份）来解决此问题解决办法一查找/etc下的groups文件，但是没有找到。只有group、group- 这2个文件，其中group文件就是我们要找的。打开此文件，将如下2段修改：uucp:x:14:uucp 修改为 uucp:x:14:uucp,ebmlock:x:54: 修改为 lock:x:54:ebm修改这个文件后，必须重启系统，才能使之起效解决办法二执行如下命令12[root@sunys ~]# chgrp uucp /var/lock/[root@sunys ~]# chmod g+w /var/lock/文件已存在 File existsissue:RXTX fhs_lock() Error: creating lock file: /var/lock/LCK..ttyS0: 文件已存在cause:有多个进程同时使用串口，端口被占用解决办法执行如下命令1[root@sunys ~]# rm /var/lock/LCK..ttyS0]]></content>
      <categories>
        <category>technology</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>technology</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
</search>
